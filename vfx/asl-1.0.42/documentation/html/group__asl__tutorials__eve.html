<!--
    Copyright 2005-2008 Adobe Systems Incorporated
    Distributed under the MIT License (see accompanying file LICENSE_1_0_0.txt
    or a copy at http://stlab.adobe.com/licenses.html)

    Some files are held under additional license.
    Please see "http://stlab.adobe.com/licenses.html" for more information.
-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
    <TITLE>Adobe Software Technology Lab: Eve</TITLE>
    <META HTTP-EQUIV="content-type" CONTENT="text/html;charset=ISO-8859-1"/>
    <LINK TYPE="text/css" REL="stylesheet" HREF="adobe_source.css"/>
    <LINK REL="alternate" TITLE="stlab.adobe.com RSS" HREF="http://sourceforge.net/export/rss2_projnews.php?group_id=132417&amp;rss_fulltext=1" TYPE="application/rss+xml"/>
    <script src="http://www.google-analytics.com/urchin.js" type="text/javascript"></script>
</head>
<body>
<div id='content'>
<table><tr>
<td colspan='5'>
    <div id='opensource_banner'>
    <table style='width: 100%; padding: 5px;'><tr>
    <td align='left'>
        <a href='index.html' style='border: none'><img src='stlab2007.jpg' alt="stlab.adobe.com"/></a>
    </td>
    <td align='right'>
        <a href='http://www.adobe.com' style='border: none'><img src='adobe_hlogo.gif' alt="Adobe Systems Incorporated"/></a>
    </td>
    </tr></table>
    </div>
</td></tr><tr>
<td valign="top">
    <div id='navtable' height='100%'>
    <div style='margin: 5px'>
        <h4>Documentation</h4>

        <a href="group__asl__overview.html">Overview</a><br/>
        <a href="asl_readme.html">Building ASL</a><br/>
        <a href="asl_toc.html">Documentation</a><br/>
        <a href="http://stlab.adobe.com/wiki/index.php/Supplementary_ASL_Documentation">Library Wiki Docs</a><br/>
        <a href="asl_indices.html">Indices</a><br/>
        <a href="http://stlab.adobe.com/perforce/">Browse Perforce</a><br/>

        <h4>More Info</h4>

        <a href="asl_release_notes.html">Release Notes</a><br/>
        <a href="http://stlab.adobe.com/wiki/">Wiki</a><br/>
        <a href="asl_search.html">Site Search</a><br/>
        <a href="licenses.html">License</a><br/>
        <a href="success_stories.html">Success Stories</a><br/>
        <a href="asl_contributors.html">Contributors</a><br/>

        <h4>Media</h4>

        <a href="http://sourceforge.net/project/showfiles.php?group_id=132417&amp;package_id=145420">Download</a><br/>
        <a href="asl_download_perforce.html">Perforce Depots</a><br/>

        <h4>Support</h4>

        <a href="http://sourceforge.net/projects/adobe-source/">ASL SourceForge Home</a><br/>
        <a href="http://sourceforge.net/mail/?group_id=132417">Mailing Lists</a><br/>
        <a href="http://sourceforge.net/forum/?group_id=132417">Discussion Forums</a><br/>
        <a href="http://sourceforge.net/tracker/?atid=724218&amp;group_id=132417&amp;func=browse">Report Bugs</a><br/>
        <a href="http://sourceforge.net/tracker/?atid=724221&amp;group_id=132417&amp;func=browse">Suggest Features</a><br/>
        <a href="asl_contributing.html">Contribute to ASL</a><br/>

        <h4>RSS</h4>

        <a href="http://sourceforge.net/export/rss2_projnews.php?group_id=132417">Short-text news</a><br/>
        <a href="http://sourceforge.net/export/rss2_projnews.php?group_id=132417&amp;rss_fulltext=1">Full-text news</a><br/>
        <a href="http://sourceforge.net/export/rss2_projfiles.php?group_id=132417">File releases</a><br/>

        <h4>Other Adobe Projects</h4>

        <a href="adobe_apollo.html">Adobe Air</a><br/>
        <a href="http://stlab.adobe.com/gil/">Adobe GIL</a><br/>
        <a href="http://stlab.adobe.com/performance/">C++ Benchmarks</a><br/>
        <a href="http://labs.adobe.com">Adobe Labs</a><br/>
        <a href="http://stlab.adobe.com/amg/">Adobe Media Gallery</a><br/>
        <a href="http://www.adobe.com/products/xmp/">Adobe XMP</a><br/>
        <a href="http://www.mozilla.org/projects/tamarin">Tamarin project<br/>(Mozilla Foundation)</a><br/>

        <h4>Other Resources</h4>

        <a href="http://boost.org">Boost</a><br/>
        <a href="http://www.riaforge.com/">RIAForge</a><br/>
        <a href="http://www.sgi.com/tech/stl">SGI STL</a><br/>
    </div>
    </div>
</td>
<td id='maintable' width="100%" valign="top">

<!-- End Header -->
<!-- Generated by Doxygen 1.5.9 -->
<div class="contents">
<h1>Eve<br>
<small>
[<a class="el" href="group__asl__tutorials.html">ASL Tutorials</a>]</small>
</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
</table>
<em>Last updated June 01, 2006 -- revisions still in progress</em><h2><a class="anchor" name="tutorials_eve_prerequsites">
Prerequisites To This Tutorial</a></h2>
<dl class="user" compact><dt><b></b></dt><dd>The following list of items is a good recommendation of stuff you should know before you attempt to work through this document:<ul>
<li>boost::function</li><li>boost::bind</li><li><a class="el" href="group__abi__container.html#ga1632a71e79b59b0348907b1cc0a2d2b">adobe::dictionary_t</a></li><li>Cursory reading of the <a class="el" href="group__eve__engine.html">Layout Engine</a> (Engine) and <a class="el" href="group__eveparser.html">Layout Library Parser</a> documentation </li></ul>
</dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>For advanced implementations, the following might be of help <em>but are not required</em>:<ul>
<li><a class="el" href="assemblage_8hpp.html">adobe/future/assemblage.hpp</a></li><li>adobe/test/visual/headers/optional_connect.hpp </li></ul>
</dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>The sample code found in the Adobe Begin implementation (especially <code>client_assembler.cpp</code>) shows a possible implementation using these techniques. Note that Adobe Begin is an experimental work in progress, and should be used loosely as an example only!</dd></dl>
<h2><a class="anchor" name="tutorials_eve_overview">
Overview</a></h2>
<dl class="user" compact><dt><b></b></dt><dd>Eve is broken up into two distinct pieces: the parser and the engine. Note that both components exist completely independently of each other, though they are built in a way that they bind together easily. We will discuss both components in turn. There is also a third component, referred to herein as the <em>assemblage code</em>, which is the client-specified code that binds the parser to the engine. </dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>The general code design for the Adobe Source Libraries is one that tries to maintain true modularity between components. Each major module within the Libraries is written with only the most basic of common, shared code (<a class="el" href="group__abi__container.html#g67964eefe4a39e86f6de5b13eb9e9c97">adobe::array_t</a>, <a class="el" href="group__abi__container.html#ga1632a71e79b59b0348907b1cc0a2d2b">adobe::dictionary_t</a>, etc.) so they are able to communicate by means common data types. Other than that, we try to maintain a strict standard whereby no component is aware of or dependent upon any other component. This allows for the swapping in and out of a component with minimal invasiveness into other parts of your code base. In order to make this possible, there is a client-side piece of code called the <em>assemblage</em> that handles the connectivity between components. When a given component is added or removed, only the assemblage need be modified. Essentially the assemblage code is the only part of the program that knows context- that is, it alone knows what components are available across the application and how they should link together.</dd></dl>
<h3><a class="anchor" name="tutorials_eve_overview_flow">
Program Flow</a></h3>
<dl class="user" compact><dt><b></b></dt><dd>The easiest way to see what is happening in a design that includes Eve is to enumerate the steps involved in solving a layout:<ol type=1>
<li>The client code specifies an Eve file for parsed, solved, and displayed.</li><li>The client code creates an <code>eve_t</code> object that is the Eve Engine instance that will manage the widgets at runtime.</li><li>The client code calls the Eve Parser with (among other parameters) an input stream and an assemblage callback.</li><li>The Eve Parser parses the input stream, notifying the assemblage callback any time a valid widget definition is found.</li><li>The assemblage callback, when it receives a hit from the Eve Parser for a valid widget, constructs a placeable_t or placeable_twopass_t and passes a reference to it (amongst other parameters) to the <code>eve_t</code> instance for layout of this new widget.</li><li>The assemblage receives a new marker for the new widget just created in the Eve Engine hierarchy, and passes it back to the Eve Parser for later use.</li><li>When the Eve Parser is finished, the client code calls the <code>evaluate</code> with the <code>eve_t</code> instance to solve for the layout.</li><li>During the course of solving the layout, the Eve Engine calls back to the client assemblage code via the layout element objects passed in for every individual widget created in the Eve Engine heirarchy.</li><li>Once a view solution has been computed, the final call to the layout element object (place) is fired for each widget to notify the client code of the positioning of every widget.</li><li>The client code goes out to the OS to create the OS-specific widgets, hierarchy, event handlers, etc.</li><li>The rest of the application takes it from there: Eve's work is done.</li></ol>
</dd></dl>
<h2><a class="anchor" name="tutorials_eve_parser">
Parser</a></h2>
<dl class="user" compact><dt><b></b></dt><dd>The interface for the parser is pretty simple. It takes a standard input file stream and a couple other parameters, including a callback by which the parser speaks to your assemblage code. Here is a sample of what it might look like: </dd></dl>
<dl class="user" compact><dt><b></b></dt><dd><div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> parse_my_eve_file(<span class="keyword">const</span> std::string&amp; path_to_file)
{
    std::ifstream           stream(path_to_file.c_str());
    <a class="code" href="structadobe_1_1line__position__t.html" title="A type detailing parser position information.">adobe::line_position_t</a>  result_line(<a class="code" href="group__adamparser.html#g017125389ca00e37008763ddb0db4f0c">adobe::eve::parse</a>(
                                stream,
                                <a class="code" href="structadobe_1_1line__position__t.html" title="A type detailing parser position information.">adobe::line_position_t</a>(path_to_file.c_str()),
                                adobe::eve::position_t(),
                                boost::bind(&amp;client_assemble, _1, _3,
                                    boost::bind(adobe::eve::evaluate_arguments(), _4))));
}
</pre></div> </dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>Note that we have yet to define what client_assemble will be- we will get to that later. Also, the result_line is used to indicate where the parsing of the definition ceased inside the input stream. </dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>So what is happening here, and what does this code do? All we are doing here is asking the Eve Parser to parse the input stream, and every time it successfully parses a widget in the view definition, it will call back to the client code by means of client_assemble. </dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>What is going on with adobe::eve::evaluate_arguments? When the parser traverses the view definition, each element in the view can contain a parameter list. Inside the parameter list are key/value pairs, or named arguments, that assist in the definition and layout of the view being defined. However when the parser sends the information to the client assemblage code, the named argument expressions are "raw", in their unevaluated states as an <a class="el" href="group__abi__container.html#g67964eefe4a39e86f6de5b13eb9e9c97">adobe::array_t</a> per expression. adobe::eve::evaluate_arguments simply takes these raw expressions and converts them to their evaluated values, packing them into an <a class="el" href="group__abi__container.html#ga1632a71e79b59b0348907b1cc0a2d2b">adobe::dictionary_t</a>. As an example, if in the Eve definition the parser finds a parameter: "my_value: 5 + 2 * 3", the resulting dictionary will have the named argument "my_value: 11" stored within. </dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>When client_assemble is called, it should work to communicate with the Eve Engine, the details of which we will look at in a bit. For now let us take a look at the guts of client_assemble.</dd></dl>
<h2><a class="anchor" name="tutorials_eve_assembler">
Assemblage Code</a></h2>
<dl class="user" compact><dt><b></b></dt><dd>In our simplified case we have a single function, client_assemble, that knows about both the Eve Parser and the Eve Engine. Note that the Eve Parser is only aware of client_assemble-- it does not know what it does, nor does it care; it merely sends the results of the parse to this callback, and expects the rest of the body of code to know what to do about it. This gives the client the ability to substitute the Eve Parser with any other parser (XML, Boost Spirit, etc). As long as the assemblage code knows how to deal with the new parser, your app can utilize the Eve Engine just as effectively. </dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>So the client_assemble code might look something like this: </dd></dl>
<dl class="user" compact><dt><b></b></dt><dd><div class="fragment"><pre class="fragment"><span class="keyword">struct </span>my_push_button
{
<span class="comment">//...</span>
    <span class="keywordtype">bool</span>             is_container() <span class="keyword">const</span>;
    <span class="keywordtype">void</span>             <a class="code" href="group__placeable__concept.html#g8cedc2f4f0d83cd648636c726f5ef8e8">measure</a>(<a class="code" href="structadobe_1_1extents__t.html" title="An intrinsic geometry class for objects with a graphical representation.">adobe::extents_t</a>&amp; result);
    <span class="keywordtype">void</span>             <a class="code" href="group__placeable__concept.html#g19fe53d590288497d46f9ef00bfff5d1">place</a>(<span class="keyword">const</span> <a class="code" href="structadobe_1_1place__data__t.html" title="Layout data interface from the engine to the client.">adobe::place_data_t</a>&amp; place_data);
<span class="comment">//...</span>
};

<a class="code" href="structadobe_1_1extents__t.html" title="An intrinsic geometry class for objects with a graphical representation.">adobe::extents_t</a> default_extents();

adobe::layoutable_t *widget_factory(<a class="code" href="classadobe_1_1name__t.html" title="A character string class for immutable strings.">adobe::name_t</a> widget_name)
{
   <span class="comment">/* a real factory goes here instead */</span>
   <span class="comment">//...</span>
   <span class="keywordflow">if</span> (widget_name == <span class="stringliteral">"push_button"</span>) {
      <span class="keywordflow">return</span> boost::ref(*<span class="keyword">new</span> adobe::placeable_t(boost::ref(*<span class="keyword">new</span> my_push_button)));
   <span class="keywordflow">else</span> <span class="keywordflow">if</span> <span class="comment">//...</span>

}

adobe::position_t client_assemble(  <span class="keyword">const</span> adobe::eve_t::position_t&amp; parent,
                                    <a class="code" href="classadobe_1_1name__t.html" title="A character string class for immutable strings.">adobe::name_t</a>                   widget_name,
                                    <span class="keyword">const</span> <a class="code" href="group__abi__container.html#ga1632a71e79b59b0348907b1cc0a2d2b">adobe::dictionary_t</a>&amp;      parameters)
{
     adobe::layoutable_t widget(widget_factory(widget_name));
     <span class="keywordflow">return</span> eve_g.add_view_element(parent.empty() ?
                                    boost::any_cast&lt;adobe::eve::position_t&gt;(parent) :
                                    adobe::eve_t::iterator(),
                                    widget-&gt;default_extents(), <span class="comment">//documentation update in progress</span>
                                    widget-&gt;is_container(),    <span class="comment">//documentation update in progress</span>
                                    parameters,
                                    widget);
}
</pre></div> </dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>There's a lot of new code being introduced here, so let us go through the main parts.</dd></dl>
<h3><a class="anchor" name="tutorials_eve_assembler_placeable">
Layout Elements</a></h3>
<dl class="user" compact><dt><b></b></dt><dd>Earlier we stated that the assemblage code is the only code that knows "context"- what components are available and how they should communicate with one another. This does not mean that the components cannot communicate with one another directly, however- just that the assemblage must dictate <em>how</em> this communication is going to happen. </dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>Note that the layout elements are written on a per-widget-type basis: they need not be different for every instance of every widget, because the semantics of a widget should not change within the same widget type. (For instance, a push button is a push button irrespective of its dimensions or how it is labeled. Another widget, like a radio button, will have different layout parameters and different means of being measured.) </dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>The simplest kind of placeable is built from a class containing a collection of member functions with appropriate signatures, each of which for a particular purpose. The collection is a generic interface for the Eve engine to communicate with a given widget's backend. The Eve Engine specifies the interface, and the client code (through the assemblage) is free to flesh out the implementation any way it sees fit. In essence the Eve Engine doesn't care how a member function arrives at the values it does, all it cares about is that it arrives at something meaningful. The assemblage linking method provides for the flexibility for an implementation to use any means of arriving at meaningful values for any widget. For instance in some cases it would make sense to wrap an OS measurement routine, whereas in other cases it would make better sense to hand-code the measurements. In either case the function can be made to fit a member function signature, and thus can be used by the Eve Engine. In case it is inconvenient to provide a class with the required member functions, layout elements can be customized to use free functions.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd>adobe::placeable_t</dd></dl>
<h3><a class="anchor" name="tutorials_eve_assembler_position_t">
adobe::eve_t::position_t</a></h3>
<dl class="user" compact><dt><b></b></dt><dd>adobe::eve_t::position_t is a means by which the Eve Engine communicates with <em>itself</em>. Internally it maintains a heirarchy of all the view widgets so it knows the parent-child relationship of each. The client assemblage code modifies this tree by means of the adobe::eve_t::add_view_element call. In each call, the client code must pass in a marker signifying the parent under which this new widget is to be placed. Upon return of the function, the Eve Engine will hand back a marker that is the position of the new view in the internal heirarchy. </dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>You really do not need to know what the marker is, just that it <em>is</em>. You should pass it back to the Eve Parser by means of the client assemblage. Note that the Eve Parser just retains the value, it doesn't do anything with it. If a subview for this widget is found the callback to client_assemble happens all over again, except this time the call uses the new marker as the parent adobe::eve_t::position_t. Again, this is an example of the parser and the engine communicating through the assemblage code, though neither knows or cares about the other. </dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>In the case of the root node, notice that the 3rd parameter of the call to adobe::eve_t::parse is an empty position_t; a test is performed in the assembler that converts that value to an empty Eve Engine marker, which will place the element being added at the root of the heirarchy. Note that it is technically possible to put more than one root in the heirarchy (thereby creating a forest) but to do so is undefined for Eve.</dd></dl>
<h3><a class="anchor" name="tutorials_eve_assembler_placeable">
Layout Elements</a></h3>
<dl class="user" compact><dt><b></b></dt><dd>The code above mentions member functions of adobe::placeable_t constructed using a factory function taking a single argument, that is the name of the widget type found by the parser. If the widget type is "push_button", the factory creates a layout element wrapping a my_push_button class whose member functions do the actual work. </dd></dl>
<dl class="user" compact><dt><b></b></dt><dd><em>Note that these member functions are all considered part of the assemblage code.</em></dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>Above we mentioned specific functions for specific widgets that handle specific needs of the Eve Engine. As an example, let's look at what might happen inside a "push_button" widget's measure proc. The Eve Engine layout element definition provides specifies the signature for the calculate proc as: </dd></dl>
<dl class="user" compact><dt><b></b></dt><dd><div class="fragment"><pre class="fragment">    <span class="keywordtype">void</span>      <a class="code" href="group__placeable__concept.html#g8cedc2f4f0d83cd648636c726f5ef8e8">measure</a>(<a class="code" href="structadobe_1_1extents__t.html" title="An intrinsic geometry class for objects with a graphical representation.">adobe::extents_t</a>&amp; geometry);
</pre></div> </dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>OK, so we know what the function signature must look like, so let's flesh out what the body might look like: </dd></dl>
<dl class="user" compact><dt><b></b></dt><dd><div class="fragment"><pre class="fragment">{
    geometry.extents_m.slice_m[horizontal].length_m = 80;
    geometry.extents_m.slice_m[vertical].length_m = 20;
}
</pre></div> </dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>The above code, for every push_button that is created, will tell the Eve Engine that the button's dimensions are width 80 and height 20. That all sounds well and good, but it's not very flexible. What would be really cool would be, given some sort of measure_string_width(...) proc, that the width of the button would be variable based on the width of the button name. Let's change the factory function so that we could instead have the factory function construct my_push_button using the parameters dictionary, so that we can extract and store the button name as, say, the data member button_name_m for later use by <a class="el" href="group__placeable__concept.html#g8cedc2f4f0d83cd648636c726f5ef8e8">measure()</a>, e.g.: </dd></dl>
<dl class="user" compact><dt><b></b></dt><dd><div class="fragment"><pre class="fragment">my_push_button::my_push_button(<span class="keyword">const</span> <a class="code" href="group__abi__container.html#ga1632a71e79b59b0348907b1cc0a2d2b">adobe::dictionary_t</a>&amp; parameters)
  : widget_name_m(parameters[adobe::static_name_t(<span class="stringliteral">"name"</span>)].get&lt;std::string&gt;())
{}

<a class="code" href="group__placeable__concept.html#g8cedc2f4f0d83cd648636c726f5ef8e8">my_push_button::measure</a>(<a class="code" href="structadobe_1_1extents__t.html" title="An intrinsic geometry class for objects with a graphical representation.">adobe::extents_t</a>&amp; geometry)
{
    geometry.<a class="code" href="structadobe_1_1extents__t.html#c9b5b50072d888b002994daf73830238">horizontal</a>().length_m = measure_string_width(button_name_m);
    geometry.<a class="code" href="structadobe_1_1extents__t.html#61586b52b21b511f9d19c4ed0c57d55a">vertical</a>().length_m = 20;
}
</pre></div> </dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>(Note that it is within measure_string_width(...) that one would fold in internationalization and localization efforts to produce well-formed dialogs for any language.) </dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>Peeling away the layers of C++ reveals this: using the dictionary_t we obtained from adobe::eve::evaluate_arguments (remember that from earlier?) we can now figure out what, according to the parse, the "name" variable of the widget is, and we can use that value to measure some sort of pixel width. Then we can pass that to the Eve Engine, and now we have what we want: a button that is as wide as it needs to be. </dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>At this point a general objection could be raised: Why not avoid the constructor argument by adding another parameter in the layout elements, namely an <a class="el" href="group__abi__container.html#ga1632a71e79b59b0348907b1cc0a2d2b">adobe::dictionary_t</a>, that the Engine can merely propagate but never use? Better yet, why not just some <code>void*</code> that the client can pack with whatever they like? The answer is this: <em>To do so is to require the Eve Engine to carry more of a burden than it absolutely needs in order to do its job</em>. In this case, the mere propagation of parameters is not the job of the Eve Engine. The job of the Eve Engine is to solve for the layout. In order to do that, we distill what is <em>actually needed</em> to accomplish that task, and use that to specify the Eve Engine API. Anything beyond the absolute minimum requirements for Eve to do its job would be "API sugar", and so should be eliminated from the API as unnecessary. (As an historical aside, this was the way the original Eve was implemented, as having a user-specified "tag" that could be anything. In every use of Eve1 the "tag" quickly became a spaghetti tunnel.) Thanks to boost::bind, we are able to pass extra parameters to other parts of the assemblage without requiring components that don't care about this extra information to have to shoulder it.</dd></dl>
<h2><a class="anchor" name="tutorials_eve_engine">
Eve Engine</a></h2>
<dl class="user" compact><dt><b></b></dt><dd>Finally, we arrive at the Eve Engine. This tutorial will not explain the details of the engine, or the parameters one can pass in order to manipulate its execution. Rather, one should check out the <a class="el" href="group__eve__engine.html">Layout Engine</a> documentation and the <a class="el" href="group__widget__reference.html">Widget Reference</a> for that information. What it will explain is the general interaction between the Eve Engine and the client assemblage code. </dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>Recall that there were a collection of functions that we provided for every widget we added to the Eve Engine hierarchy. Once all the widgets have been added, we call the following: </dd></dl>
<dl class="user" compact><dt><b></b></dt><dd><div class="fragment"><pre class="fragment">eve_g-&gt;evaluate(<a class="code" href="classadobe_1_1eve__t.html#67540b62077684cd126b4ff2d2919a7cfe6c297690b0e68c36563da11dc7b0ea">adobe::eve_t::evaluate_flat</a>);
</pre></div> </dd></dl>
<dl class="user" compact><dt><b></b></dt><dd><code>evaluate</code> sets the engine in motion, at which point layout element members will start getting invoked. There are several passes Eve takes when solving the layout, and there are corresponding functions that get invoked in each one. It is important to know the order in which the functions are invoked for a given widget:<ul>
<li>measure (for placeable_t), or measure_horizontal (for placeable_twopass_t)</li><li>measure_vertical (for placeable_twopass_t only)</li><li>place </li></ul>
</dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>Each of these function will return state to the Eve Engine, and will affect the parameters of subsequent call to the same widget. You are guaranteed that each function, if called, will be called in the order listed above for a given widget. You are not guaranteed that a function will be called. The case in which Eve will call a function is if it needs to. I know this sounds obvious, but there are cases when Eve will not require calling some of the functions. One case is in the process of resizing a dialog: all the views have already had their measurement functions called in a previous pass when the dialog was first laid out. Thus the measurement functions will not get called when a dialog is resized. When the remaining functions are called, however, you can be sure that it will be in the order listed above. </dd></dl>
</div>

<!-- Begin Footer -->
</td></tr>
</table>
</div> <!-- content -->
<div class='footerdiv'>
    <div id='footersub'>
        <ul>
            <li><a href="http://www.adobe.com/go/gftray_foot_aboutadobe">Company</a>&nbsp;|&nbsp;</li>
            <li><a href="http://www.adobe.com/go/gftray_foot_privacy_security">Online Privacy Policy</a>&nbsp;|&nbsp;</li>
            <li><a href="http://www.adobe.com/go/gftray_foot_terms">Terms of Use</a>&nbsp;|&nbsp;</li>
    
            <li><a href="http://www.adobe.com/go/gftray_foot_contact_adobe">Contact Us</a>&nbsp;|&nbsp;</li>
            <li><a href="http://www.adobe.com/go/gftray_foot_accessibility">Accessibility</a>&nbsp;|&nbsp;</li>
            <li><a href="http://www.adobe.com/go/gftray_foot_report_piracy">Report Piracy</a>&nbsp;|&nbsp;</li>
            <li><a href="http://www.adobe.com/go/gftray_foot_permissions_trademarks">Permissions &amp; Trademarks</a>&nbsp;|&nbsp;</li>
            <li><a href="http://www.adobe.com/go/gftray_foot_product_license_agreements">Product License Agreements</a>&nbsp;|&nbsp;</li>
    
            <li><a href="http://www.adobe.com/go/gftray_foot_feedback">Send Feedback</a></li>
        </ul>
        <div>
            <p>Copyright &#169; 2006-2007 Adobe Systems Incorporated.</p>
            <p>Use of this website signifies your agreement to the <a href="http://www.adobe.com/go/gftray_foot_terms">Terms of Use</a> and <a href="http://www.adobe.com/go/gftray_foot_privacy_security">Online Privacy Policy</a>.</p>
            <p>Search powered by <a href="http://www.google.com/" target="new">Google</a></p>
        </div>
	</div>
</div>
<script type="text/javascript">
_uacct = "UA-396569-1";
urchinTracker();
</script>
</body>
</html>
