<!--
    Copyright 2005-2008 Adobe Systems Incorporated
    Distributed under the MIT License (see accompanying file LICENSE_1_0_0.txt
    or a copy at http://stlab.adobe.com/licenses.html)

    Some files are held under additional license.
    Please see "http://stlab.adobe.com/licenses.html" for more information.
-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
    <TITLE>Adobe Software Technology Lab: selection</TITLE>
    <META HTTP-EQUIV="content-type" CONTENT="text/html;charset=ISO-8859-1"/>
    <LINK TYPE="text/css" REL="stylesheet" HREF="adobe_source.css"/>
    <LINK REL="alternate" TITLE="stlab.adobe.com RSS" HREF="http://sourceforge.net/export/rss2_projnews.php?group_id=132417&amp;rss_fulltext=1" TYPE="application/rss+xml"/>
    <script src="http://www.google-analytics.com/urchin.js" type="text/javascript"></script>
</head>
<body>
<div id='content'>
<table><tr>
<td colspan='5'>
    <div id='opensource_banner'>
    <table style='width: 100%; padding: 5px;'><tr>
    <td align='left'>
        <a href='index.html' style='border: none'><img src='stlab2007.jpg' alt="stlab.adobe.com"/></a>
    </td>
    <td align='right'>
        <a href='http://www.adobe.com' style='border: none'><img src='adobe_hlogo.gif' alt="Adobe Systems Incorporated"/></a>
    </td>
    </tr></table>
    </div>
</td></tr><tr>
<td valign="top">
    <div id='navtable' height='100%'>
    <div style='margin: 5px'>
        <h4>Documentation</h4>

        <a href="group__asl__overview.html">Overview</a><br/>
        <a href="asl_readme.html">Building ASL</a><br/>
        <a href="asl_toc.html">Documentation</a><br/>
        <a href="http://stlab.adobe.com/wiki/index.php/Supplementary_ASL_Documentation">Library Wiki Docs</a><br/>
        <a href="asl_indices.html">Indices</a><br/>
        <a href="http://stlab.adobe.com/perforce/">Browse Perforce</a><br/>

        <h4>More Info</h4>

        <a href="asl_release_notes.html">Release Notes</a><br/>
        <a href="http://stlab.adobe.com/wiki/">Wiki</a><br/>
        <a href="asl_search.html">Site Search</a><br/>
        <a href="licenses.html">License</a><br/>
        <a href="success_stories.html">Success Stories</a><br/>
        <a href="asl_contributors.html">Contributors</a><br/>

        <h4>Media</h4>

        <a href="http://sourceforge.net/project/showfiles.php?group_id=132417&amp;package_id=145420">Download</a><br/>
        <a href="asl_download_perforce.html">Perforce Depots</a><br/>

        <h4>Support</h4>

        <a href="http://sourceforge.net/projects/adobe-source/">ASL SourceForge Home</a><br/>
        <a href="http://sourceforge.net/mail/?group_id=132417">Mailing Lists</a><br/>
        <a href="http://sourceforge.net/forum/?group_id=132417">Discussion Forums</a><br/>
        <a href="http://sourceforge.net/tracker/?atid=724218&amp;group_id=132417&amp;func=browse">Report Bugs</a><br/>
        <a href="http://sourceforge.net/tracker/?atid=724221&amp;group_id=132417&amp;func=browse">Suggest Features</a><br/>
        <a href="asl_contributing.html">Contribute to ASL</a><br/>

        <h4>RSS</h4>

        <a href="http://sourceforge.net/export/rss2_projnews.php?group_id=132417">Short-text news</a><br/>
        <a href="http://sourceforge.net/export/rss2_projnews.php?group_id=132417&amp;rss_fulltext=1">Full-text news</a><br/>
        <a href="http://sourceforge.net/export/rss2_projfiles.php?group_id=132417">File releases</a><br/>

        <h4>Other Adobe Projects</h4>

        <a href="adobe_apollo.html">Adobe Air</a><br/>
        <a href="http://stlab.adobe.com/gil/">Adobe GIL</a><br/>
        <a href="http://stlab.adobe.com/performance/">C++ Benchmarks</a><br/>
        <a href="http://labs.adobe.com">Adobe Labs</a><br/>
        <a href="http://stlab.adobe.com/amg/">Adobe Media Gallery</a><br/>
        <a href="http://www.adobe.com/products/xmp/">Adobe XMP</a><br/>
        <a href="http://www.mozilla.org/projects/tamarin">Tamarin project<br/>(Mozilla Foundation)</a><br/>

        <h4>Other Resources</h4>

        <a href="http://boost.org">Boost</a><br/>
        <a href="http://www.riaforge.com/">RIAForge</a><br/>
        <a href="http://www.sgi.com/tech/stl">SGI STL</a><br/>
    </div>
    </div>
</td>
<td id='maintable' width="100%" valign="top">

<!-- End Header -->
<!-- Generated by Doxygen 1.5.9 -->
<div class="contents">
<h1>selection<br>
<small>
[<a class="el" href="group__algorithm.html">Algorithms</a>]</small>
</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structadobe_1_1logical__xor.html">logical_xor&lt; C1, C2 &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">xor funtion object  <a href="structadobe_1_1logical__xor.html#_details">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Selection , typename ForwardRange &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Selection&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__selection__algorithms.html#ga8a1c40a0ae2863e8bec07bef570bd3d">index_set_to_selection</a> (const ForwardRange &amp;index_set)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Selection &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__selection__algorithms.html#g03ed299bcedc1abd1fd18b7ea66aa632">invert</a> (Selection &amp;x)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Selection &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__selection__algorithms.html#g1779b4acd8a58bcce83010a80e8d5c87">is_selected</a> (const Selection &amp;x, typename Selection::value_type index)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Selection , typename ForwardRange , typename OutputIterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">OutputIterator&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__selection__algorithms.html#g6e207a92292089cf5773f31fc8db0960">selection_copy</a> (const Selection &amp;x, const ForwardRange &amp;range, OutputIterator output)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Selection1 , typename Selection2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Selection1&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__selection__algorithms.html#gba7abcd0b4a59b1619c0cba752b9e88e">selection_difference</a> (const Selection1 &amp;x, const Selection2 &amp;y)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename S1 , typename S2 , typename O , typename C &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">O&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__selection__algorithms.html#gdfc1db4416b8a27925573752bb801e6c">selection_difference</a> (S1 s1_first, S1 s1_last, S2 s2_first, S2 s2_last, O output, C comp, bool s1_inside=false, bool s2_inside=false)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Selection &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::pair&lt; typename <br class="typebreak">
boost::range_const_iterator<br class="typebreak">
&lt; Selection &gt;::type, typename <br class="typebreak">
boost::range_size&lt; Selection &gt;<br class="typebreak">
::type &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__selection__algorithms.html#gc51b8afb0f8548cd72c4a9e11cee9eed">selection_find_boundary</a> (const Selection &amp;selection, typename Selection::size_type p)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Selection &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::pair&lt; typename <br class="typebreak">
boost::range_const_iterator<br class="typebreak">
&lt; Selection &gt;::type, typename <br class="typebreak">
boost::range_size&lt; Selection &gt;<br class="typebreak">
::type &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__selection__algorithms.html#g1e4b75974f756e53c3725bd4e938aa3a">selection_find_boundary</a> (const Selection &amp;selection, typename Selection::size_type p, std::forward_iterator_tag)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Selection &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::pair&lt; typename <br class="typebreak">
boost::range_const_iterator<br class="typebreak">
&lt; Selection &gt;::type, typename <br class="typebreak">
boost::range_size&lt; Selection &gt;<br class="typebreak">
::type &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__selection__algorithms.html#g6c57905062dfe8a3ac00091dcf5988a0">selection_find_boundary</a> (const Selection &amp;selection, typename Selection::size_type p, std::random_access_iterator_tag)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Selection , typename ForwardRange , typename UnaryFunction &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">UnaryFunction&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__selection__algorithms.html#g7c95cb85342645fec5317e3ef1498827">selection_foreach</a> (const Selection &amp;x, const ForwardRange &amp;range, UnaryFunction proc)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Selection1 , typename Selection2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__selection__algorithms.html#g93301a2ef8bc9abd5fe30cc63f93ae4c">selection_includes</a> (const Selection1 &amp;x, const Selection2 &amp;y)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename S1 , typename S2 , typename C &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__selection__algorithms.html#g4fbce39cf92e583a3cab0b0ab1a89f38">selection_includes</a> (S1 s1_first, S1 s1_last, S2 s2_first, S2 s2_last, C comp, bool s1_inside=false, bool s2_inside=false)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Selection1 , typename Selection2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Selection1&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__selection__algorithms.html#gd8dc2b1866edc0f0577c00148cbf0764">selection_intersection</a> (const Selection1 &amp;x, const Selection2 &amp;y)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename S1 , typename S2 , typename O , typename C &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">O&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__selection__algorithms.html#gb40015a55c3983456d818692e403e666">selection_intersection</a> (S1 s1_first, S1 s1_last, S2 s2_first, S2 s2_last, O output, C comp, bool s1_inside=false, bool s2_inside=false)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename S1 , typename S2 , typename O , typename P , typename C &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">O&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__selection__algorithms.html#gb4ec6e3f07976c32c6e9a6b7d17a5617">selection_operation</a> (S1 s1_first, S1 s1_last, S2 s2_first, S2 s2_last, O output, bool s1_inside, bool s2_inside, P pred, C comp)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename S , typename O , typename P &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">O&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__selection__algorithms.html#g2b51445eaf0e6a04ed3977167a2c3623">selection_operation_remainder</a> (S first, S last, O output, bool this_inside, bool other_inside, P pred)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Selection , typename ForwardRange , typename O1 , typename O2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::pair&lt; O1, O2 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__selection__algorithms.html#ge63dbeb5053ef98d07c64a12da796d15">selection_partition_copy</a> (const Selection &amp;selection, ForwardRange &amp;range, O1 false_output, O2 true_output)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Selection , typename ForwardRange &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">boost::range_iterator<br class="typebreak">
&lt; ForwardRange &gt;::type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__selection__algorithms.html#g1c16f366150273a7a0ad9e4e532a8c79">selection_stable_partition</a> (const Selection &amp;selection, ForwardRange &amp;range)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename SelectionIterator , typename RangeIterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">RangeIterator&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__selection__algorithms.html#ga3ea568d2a02b1c030de276c101b7ec8">selection_stable_partition</a> (SelectionIterator selection_first, SelectionIterator selection_last, RangeIterator first, RangeIterator range_first, RangeIterator range_last, std::size_t boundary_count=0)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Selection , typename ForwardRange &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::pair&lt; typename <br class="typebreak">
boost::range_iterator<br class="typebreak">
&lt; ForwardRange &gt;::type, <br class="typebreak">
typename boost::range_iterator<br class="typebreak">
&lt; ForwardRange &gt;::type &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__selection__algorithms.html#gfb99a9930d0c111d7f6560dacdc50b23">selection_stable_partition_about</a> (const Selection &amp;selection, ForwardRange &amp;range, std::size_t p, typename boost::range_size&lt; Selection &gt;::type prior_boundary_count=0)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Selection1 , typename Selection2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Selection1&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__selection__algorithms.html#g22b88fa69cfe4fa510a78596d4db07ad">selection_symmetric_difference</a> (const Selection1 &amp;x, const Selection2 &amp;y)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename S1 , typename S2 , typename O , typename C &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">O&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__selection__algorithms.html#g2b8d3fe6f353246974f3fc8641c9640f">selection_symmetric_difference</a> (S1 s1_first, S1 s1_last, S2 s2_first, S2 s2_last, O output, C comp, bool s1_inside=false, bool s2_inside=false)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Selection , typename OutputIterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">OutputIterator&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__selection__algorithms.html#ga1b7513dba97d3b2447fd2ea35c8f0e2">selection_to_index_set</a> (const Selection &amp;selection, typename boost::range_size&lt; Selection &gt;::type max_index, OutputIterator output)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Selection1 , typename Selection2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Selection1&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__selection__algorithms.html#ga2f8f3bba5b11918f0838b727a4d7076">selection_union</a> (const Selection1 &amp;x, const Selection2 &amp;y)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename S1 , typename S2 , typename O , typename C &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">O&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__selection__algorithms.html#g7d151d2d10f526bacd2264accb8198ad">selection_union</a> (S1 s1_first, S1 s1_last, S2 s2_first, S2 s2_last, O output, C comp, bool s1_inside=false, bool s2_inside=false)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Selection , typename ForwardRange &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">boost::range_size&lt; Selection &gt;<br class="typebreak">
::type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__selection__algorithms.html#ge260f209173f7775b87df5c4ee3b68c2">size</a> (const Selection &amp;x, const ForwardRange &amp;range)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Selection &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">boost::range_size&lt; Selection &gt;<br class="typebreak">
::type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__selection__algorithms.html#g7c5bdb55e42beda2cd6acbe643ef4fa2">size</a> (const Selection &amp;x)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Selection &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__selection__algorithms.html#g3c24719c51126b824d063b9caec4d3c6">start_selected</a> (const Selection &amp;x)</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user" compact><dt><b>Terminology:</b></dt><dd><ul>
<li>Selection: A collection of iterators in sorted order over a sequence. When considering a sequence the selection is initially "off". As the algorithm passes over a position within the list of selection points, the selection is toggled.</li></ul>
</dd></dl>
This set of functions behave in similar manner to the suite of operations in the STL. What makes these algorithms different from their STL counterparts is that you are supplied the initial ranges of "good" and "bad" positions in the form of the selection; thus there is no need for a predicate. It is as if the "floor" of the algorithm's processing tree were removed, as the leaf nodes are merely for discerning the state of an <a class="el" href="structadobe_1_1element.html">element</a> by means of the predicate. <hr><h2>Function Documentation</h2>
<a class="anchor" name="ga8a1c40a0ae2863e8bec07bef570bd3d"></a><!-- doxytag: member="adobe::index_set_to_selection" ref="ga8a1c40a0ae2863e8bec07bef570bd3d" args="(const ForwardRange &amp;index_set)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Selection adobe::index_set_to_selection           </td>
          <td>(</td>
          <td class="paramtype">const ForwardRange &amp;&nbsp;</td>
          <td class="paramname"> <em>index_set</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Takes a set of indices and converts them to a boundary-based Selection 
<p>Definition at line <a class="el" href="selection__algorithms_8hpp_source.html#l00901">901</a> of file <a class="el" href="selection__algorithms_8hpp_source.html">selection_algorithms.hpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="g03ed299bcedc1abd1fd18b7ea66aa632"></a><!-- doxytag: member="adobe::invert" ref="g03ed299bcedc1abd1fd18b7ea66aa632" args="(Selection &amp;x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void adobe::invert           </td>
          <td>(</td>
          <td class="paramtype">Selection &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
invert implementation 
<p>

<p>Definition at line <a class="el" href="selection__algorithms_8hpp_source.html#l00437">437</a> of file <a class="el" href="selection__algorithms_8hpp_source.html">selection_algorithms.hpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="g1779b4acd8a58bcce83010a80e8d5c87"></a><!-- doxytag: member="adobe::is_selected" ref="g1779b4acd8a58bcce83010a80e8d5c87" args="(const Selection &amp;x, typename Selection::value_type index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool adobe::is_selected           </td>
          <td>(</td>
          <td class="paramtype">const Selection &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Selection::value_type&nbsp;</td>
          <td class="paramname"> <em>index</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Whether or not <code>index</code> is contained within Selection <code>x</code>. </dd></dl>

<p>Definition at line <a class="el" href="selection__algorithms_8hpp_source.html#l00516">516</a> of file <a class="el" href="selection__algorithms_8hpp_source.html">selection_algorithms.hpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="g6e207a92292089cf5773f31fc8db0960"></a><!-- doxytag: member="adobe::selection_copy" ref="g6e207a92292089cf5773f31fc8db0960" args="(const Selection &amp;x, const ForwardRange &amp;range, OutputIterator output)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator adobe::selection_copy           </td>
          <td>(</td>
          <td class="paramtype">const Selection &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ForwardRange &amp;&nbsp;</td>
          <td class="paramname"> <em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&nbsp;</td>
          <td class="paramname"> <em>output</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="todo" compact><dt><b><a class="el" href="todo.html#_todo000023">Todo:</a></b></dt><dd>(fbrereto) this looks eerily familiar to selection_foreach; they can probably collapse with an "assign and advance" iterator adaptor wrapped over the output iterator. </dd></dl>

<p>Definition at line <a class="el" href="selection__algorithms_8hpp_source.html#l00532">532</a> of file <a class="el" href="selection__algorithms_8hpp_source.html">selection_algorithms.hpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="gba7abcd0b4a59b1619c0cba752b9e88e"></a><!-- doxytag: member="adobe::selection_difference" ref="gba7abcd0b4a59b1619c0cba752b9e88e" args="(const Selection1 &amp;x, const Selection2 &amp;y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Selection1 adobe::selection_difference           </td>
          <td>(</td>
          <td class="paramtype">const Selection1 &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Selection2 &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
selection_difference implementation 
<p>

<p>Definition at line <a class="el" href="selection__algorithms_8hpp_source.html#l00370">370</a> of file <a class="el" href="selection__algorithms_8hpp_source.html">selection_algorithms.hpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="gdfc1db4416b8a27925573752bb801e6c"></a><!-- doxytag: member="adobe::selection_difference" ref="gdfc1db4416b8a27925573752bb801e6c" args="(S1 s1_first, S1 s1_last, S2 s2_first, S2 s2_last, O output, C comp, bool s1_inside=false, bool s2_inside=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">O adobe::selection_difference           </td>
          <td>(</td>
          <td class="paramtype">S1&nbsp;</td>
          <td class="paramname"> <em>s1_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S1&nbsp;</td>
          <td class="paramname"> <em>s1_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S2&nbsp;</td>
          <td class="paramname"> <em>s2_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S2&nbsp;</td>
          <td class="paramname"> <em>s2_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O&nbsp;</td>
          <td class="paramname"> <em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&nbsp;</td>
          <td class="paramname"> <em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>s1_inside</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>s2_inside</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
selection_difference implementation 
<p>

<p>Definition at line <a class="el" href="selection__algorithms_8hpp_source.html#l00226">226</a> of file <a class="el" href="selection__algorithms_8hpp_source.html">selection_algorithms.hpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="gc51b8afb0f8548cd72c4a9e11cee9eed"></a><!-- doxytag: member="adobe::selection_find_boundary" ref="gc51b8afb0f8548cd72c4a9e11cee9eed" args="(const Selection &amp;selection, typename Selection::size_type p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;typename boost::range_const_iterator&lt;Selection&gt;::type, typename boost::range_size&lt;Selection&gt;::type&gt; adobe::selection_find_boundary           </td>
          <td>(</td>
          <td class="paramtype">const Selection &amp;&nbsp;</td>
          <td class="paramname"> <em>selection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Selection::size_type&nbsp;</td>
          <td class="paramname"> <em>p</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
selection_find_boundary will take a selection and, given a position p, will divide the selection into two subsets: the subset of the selection before (or at) p and the subset of the selection selection after p.<p>
This will dispatch to the appropriate split_selection implementation based on the iterator_category of the iterators.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>selection</em>&nbsp;</td><td>is a container modeling the SequenceConcept </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>p</em>&nbsp;</td><td>the point at which the selection is to be split</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A <a class="el" href="structadobe_1_1pair.html">pair</a> of values. The first is a SelectionIterator to an index divding the selection by p. The second value is a count of the number of selection boundaries iterated over to get to the SelectionIterator. </dd></dl>

<p>Definition at line <a class="el" href="selection__algorithms_8hpp_source.html#l00733">733</a> of file <a class="el" href="selection__algorithms_8hpp_source.html">selection_algorithms.hpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="g1e4b75974f756e53c3725bd4e938aa3a"></a><!-- doxytag: member="adobe::selection_find_boundary" ref="g1e4b75974f756e53c3725bd4e938aa3a" args="(const Selection &amp;selection, typename Selection::size_type p, std::forward_iterator_tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;typename boost::range_const_iterator&lt;Selection&gt;::type, typename boost::range_size&lt;Selection&gt;::type&gt; adobe::selection_find_boundary           </td>
          <td>(</td>
          <td class="paramtype">const Selection &amp;&nbsp;</td>
          <td class="paramname"> <em>selection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Selection::size_type&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::forward_iterator_tag&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This is a ForwardIterator implementation of selection_find_boundary 
<p>Definition at line <a class="el" href="selection__algorithms_8hpp_source.html#l00689">689</a> of file <a class="el" href="selection__algorithms_8hpp_source.html">selection_algorithms.hpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="g6c57905062dfe8a3ac00091dcf5988a0"></a><!-- doxytag: member="adobe::selection_find_boundary" ref="g6c57905062dfe8a3ac00091dcf5988a0" args="(const Selection &amp;selection, typename Selection::size_type p, std::random_access_iterator_tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;typename boost::range_const_iterator&lt;Selection&gt;::type, typename boost::range_size&lt;Selection&gt;::type&gt; adobe::selection_find_boundary           </td>
          <td>(</td>
          <td class="paramtype">const Selection &amp;&nbsp;</td>
          <td class="paramname"> <em>selection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Selection::size_type&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::random_access_iterator_tag&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This is a RandomAccessIterator implementation of selection_find_boundary 
<p>Definition at line <a class="el" href="selection__algorithms_8hpp_source.html#l00667">667</a> of file <a class="el" href="selection__algorithms_8hpp_source.html">selection_algorithms.hpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="g7c95cb85342645fec5317e3ef1498827"></a><!-- doxytag: member="adobe::selection_foreach" ref="g7c95cb85342645fec5317e3ef1498827" args="(const Selection &amp;x, const ForwardRange &amp;range, UnaryFunction proc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UnaryFunction adobe::selection_foreach           </td>
          <td>(</td>
          <td class="paramtype">const Selection &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ForwardRange &amp;&nbsp;</td>
          <td class="paramname"> <em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryFunction&nbsp;</td>
          <td class="paramname"> <em>proc</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
selection_foreach implementation 
<p>

<p>Definition at line <a class="el" href="selection__algorithms_8hpp_source.html#l00626">626</a> of file <a class="el" href="selection__algorithms_8hpp_source.html">selection_algorithms.hpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="g93301a2ef8bc9abd5fe30cc63f93ae4c"></a><!-- doxytag: member="adobe::selection_includes" ref="g93301a2ef8bc9abd5fe30cc63f93ae4c" args="(const Selection1 &amp;x, const Selection2 &amp;y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool adobe::selection_includes           </td>
          <td>(</td>
          <td class="paramtype">const Selection1 &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Selection2 &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
selection_includes implementation 
<p>

<p>Definition at line <a class="el" href="selection__algorithms_8hpp_source.html#l00418">418</a> of file <a class="el" href="selection__algorithms_8hpp_source.html">selection_algorithms.hpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="g4fbce39cf92e583a3cab0b0ab1a89f38"></a><!-- doxytag: member="adobe::selection_includes" ref="g4fbce39cf92e583a3cab0b0ab1a89f38" args="(S1 s1_first, S1 s1_last, S2 s2_first, S2 s2_last, C comp, bool s1_inside=false, bool s2_inside=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool adobe::selection_includes           </td>
          <td>(</td>
          <td class="paramtype">S1&nbsp;</td>
          <td class="paramname"> <em>s1_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S1&nbsp;</td>
          <td class="paramname"> <em>s1_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S2&nbsp;</td>
          <td class="paramname"> <em>s2_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S2&nbsp;</td>
          <td class="paramname"> <em>s2_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&nbsp;</td>
          <td class="paramname"> <em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>s1_inside</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>s2_inside</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
selection_includes implementation 
<p>

<p>Definition at line <a class="el" href="selection__algorithms_8hpp_source.html#l00280">280</a> of file <a class="el" href="selection__algorithms_8hpp_source.html">selection_algorithms.hpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="gd8dc2b1866edc0f0577c00148cbf0764"></a><!-- doxytag: member="adobe::selection_intersection" ref="gd8dc2b1866edc0f0577c00148cbf0764" args="(const Selection1 &amp;x, const Selection2 &amp;y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Selection1 adobe::selection_intersection           </td>
          <td>(</td>
          <td class="paramtype">const Selection1 &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Selection2 &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
selection_intersection implementation 
<p>

<p>Definition at line <a class="el" href="selection__algorithms_8hpp_source.html#l00322">322</a> of file <a class="el" href="selection__algorithms_8hpp_source.html">selection_algorithms.hpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="gb40015a55c3983456d818692e403e666"></a><!-- doxytag: member="adobe::selection_intersection" ref="gb40015a55c3983456d818692e403e666" args="(S1 s1_first, S1 s1_last, S2 s2_first, S2 s2_last, O output, C comp, bool s1_inside=false, bool s2_inside=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">O adobe::selection_intersection           </td>
          <td>(</td>
          <td class="paramtype">S1&nbsp;</td>
          <td class="paramname"> <em>s1_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S1&nbsp;</td>
          <td class="paramname"> <em>s1_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S2&nbsp;</td>
          <td class="paramname"> <em>s2_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S2&nbsp;</td>
          <td class="paramname"> <em>s2_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O&nbsp;</td>
          <td class="paramname"> <em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&nbsp;</td>
          <td class="paramname"> <em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>s1_inside</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>s2_inside</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
selection_intersection implementation 
<p>

<p>Definition at line <a class="el" href="selection__algorithms_8hpp_source.html#l00198">198</a> of file <a class="el" href="selection__algorithms_8hpp_source.html">selection_algorithms.hpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="gb4ec6e3f07976c32c6e9a6b7d17a5617"></a><!-- doxytag: member="adobe::selection_operation" ref="gb4ec6e3f07976c32c6e9a6b7d17a5617" args="(S1 s1_first, S1 s1_last, S2 s2_first, S2 s2_last, O output, bool s1_inside, bool s2_inside, P pred, C comp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">O adobe::selection_operation           </td>
          <td>(</td>
          <td class="paramtype">S1&nbsp;</td>
          <td class="paramname"> <em>s1_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S1&nbsp;</td>
          <td class="paramname"> <em>s1_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S2&nbsp;</td>
          <td class="paramname"> <em>s2_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S2&nbsp;</td>
          <td class="paramname"> <em>s2_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O&nbsp;</td>
          <td class="paramname"> <em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>s1_inside</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>s2_inside</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&nbsp;</td>
          <td class="paramname"> <em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&nbsp;</td>
          <td class="paramname"> <em>comp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
selection_operation implementation 
<p>

<p>Definition at line <a class="el" href="selection__algorithms_8hpp_source.html#l00109">109</a> of file <a class="el" href="selection__algorithms_8hpp_source.html">selection_algorithms.hpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="g2b51445eaf0e6a04ed3977167a2c3623"></a><!-- doxytag: member="adobe::selection_operation_remainder" ref="g2b51445eaf0e6a04ed3977167a2c3623" args="(S first, S last, O output, bool this_inside, bool other_inside, P pred)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">O adobe::selection_operation_remainder           </td>
          <td>(</td>
          <td class="paramtype">S&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S&nbsp;</td>
          <td class="paramname"> <em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O&nbsp;</td>
          <td class="paramname"> <em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>this_inside</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>other_inside</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&nbsp;</td>
          <td class="paramname"> <em>pred</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
When one selection is exhausted this algorithm will complete the selection operation for the remainder of the other selection. 
<p>Definition at line <a class="el" href="selection__algorithms_8hpp_source.html#l00057">57</a> of file <a class="el" href="selection__algorithms_8hpp_source.html">selection_algorithms.hpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="ge63dbeb5053ef98d07c64a12da796d15"></a><!-- doxytag: member="adobe::selection_partition_copy" ref="ge63dbeb5053ef98d07c64a12da796d15" args="(const Selection &amp;selection, ForwardRange &amp;range, O1 false_output, O2 true_output)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;O1, O2&gt; adobe::selection_partition_copy           </td>
          <td>(</td>
          <td class="paramtype">const Selection &amp;&nbsp;</td>
          <td class="paramname"> <em>selection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardRange &amp;&nbsp;</td>
          <td class="paramname"> <em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O1&nbsp;</td>
          <td class="paramname"> <em>false_output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O2&nbsp;</td>
          <td class="paramname"> <em>true_output</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
selection_partition_copy implementation 
<p>

<p>Definition at line <a class="el" href="selection__algorithms_8hpp_source.html#l00576">576</a> of file <a class="el" href="selection__algorithms_8hpp_source.html">selection_algorithms.hpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="g1c16f366150273a7a0ad9e4e532a8c79"></a><!-- doxytag: member="adobe::selection_stable_partition" ref="g1c16f366150273a7a0ad9e4e532a8c79" args="(const Selection &amp;selection, ForwardRange &amp;range)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::range_iterator&lt;ForwardRange&gt;::type adobe::selection_stable_partition           </td>
          <td>(</td>
          <td class="paramtype">const Selection &amp;&nbsp;</td>
          <td class="paramname"> <em>selection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardRange &amp;&nbsp;</td>
          <td class="paramname"> <em>range</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A SelectionConcept-based version of <code>selection_stable_partition</code>. 
<p>Definition at line <a class="el" href="selection__algorithms_8hpp_source.html#l00817">817</a> of file <a class="el" href="selection__algorithms_8hpp_source.html">selection_algorithms.hpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="ga3ea568d2a02b1c030de276c101b7ec8"></a><!-- doxytag: member="adobe::selection_stable_partition" ref="ga3ea568d2a02b1c030de276c101b7ec8" args="(SelectionIterator selection_first, SelectionIterator selection_last, RangeIterator first, RangeIterator range_first, RangeIterator range_last, std::size_t boundary_count=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RangeIterator adobe::selection_stable_partition           </td>
          <td>(</td>
          <td class="paramtype">SelectionIterator&nbsp;</td>
          <td class="paramname"> <em>selection_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SelectionIterator&nbsp;</td>
          <td class="paramname"> <em>selection_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RangeIterator&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RangeIterator&nbsp;</td>
          <td class="paramname"> <em>range_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RangeIterator&nbsp;</td>
          <td class="paramname"> <em>range_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&nbsp;</td>
          <td class="paramname"> <em>boundary_count</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
stable_partition_selection takes a collection of elements defined by a selection and partitons them according to whether or not they are part of the selection. The algorithm is stable. The result is an iterator that is the boundary between the two partitions. For example:<p>
<pre>
    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30
           |---R1----|              |------R2------|              |------R3------|
    </pre><p>
becomes:<p>
<pre>
    1 2 3 4 10 11 12 13 14 20 21 22 23 24 30 5 6 7 8 9 15 16 17 18 19 25 26 27 28 29
                                            |---------------------------------------|
                                            p
    </pre><p>
<dl class="user" compact><dt><b>Storage Requirements:</b></dt><dd></dd></dl>
The algorithm is in-situ.<p>
<dl class="user" compact><dt><b>Time Complexity:</b></dt><dd></dd></dl>
<code>O(N log N)</code>, where <code>N</code> is the number of elements affected by the algorithm. This is a range from the first item affected (be that the first item in the selection, or p if p comes before it) to the last item affected (be that one before the last item in the selection, or p if p comes after it). 
<p>Definition at line <a class="el" href="selection__algorithms_8hpp_source.html#l00780">780</a> of file <a class="el" href="selection__algorithms_8hpp_source.html">selection_algorithms.hpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="gfb99a9930d0c111d7f6560dacdc50b23"></a><!-- doxytag: member="adobe::selection_stable_partition_about" ref="gfb99a9930d0c111d7f6560dacdc50b23" args="(const Selection &amp;selection, ForwardRange &amp;range, std::size_t p, typename boost::range_size&lt; Selection &gt;::type prior_boundary_count=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;typename boost::range_iterator&lt;ForwardRange&gt;::type, typename boost::range_iterator&lt;ForwardRange&gt;::type&gt; adobe::selection_stable_partition_about           </td>
          <td>(</td>
          <td class="paramtype">const Selection &amp;&nbsp;</td>
          <td class="paramname"> <em>selection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardRange &amp;&nbsp;</td>
          <td class="paramname"> <em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename boost::range_size&lt; Selection &gt;::type&nbsp;</td>
          <td class="paramname"> <em>prior_boundary_count</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
stable_partition_selection_about takes a collection of elements defined by a selection and moves them to a position (p) within the sequence. The algorithm is stable. The result is a <a class="el" href="structadobe_1_1pair.html">pair</a> of iterators [ p_first, p_last ) that contain the selection moved to p. For example:<p>
<pre>
    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30
           |---R1----|              |------R2------|        p     |------R3------|
    </pre><p>
becomes:<p>
<pre>
    1 2 3 4 10 11 12 13 14 20 21 22 5 6 7 8 9 15 16 17 18 19 25 26 27 28 29 23 24 30
                                   |---------------------------------------|
                                   p_first                                 p_last
    </pre><p>
The problem is broken down into two basic subproblems, namely, moving those ranges that are before p forward to p, and moving those ranges after p backward to p. These two problems are each an issue of modified stable partitioning.<p>
<dl class="user" compact><dt><b>Storage Requirements:</b></dt><dd></dd></dl>
The algorithm is in-situ.<p>
<dl class="user" compact><dt><b>Time Complexity:</b></dt><dd></dd></dl>
<code>O(N log N)</code>, where <code>N</code> is the number of elements affected by the algorithm. This is a range from the first item affected (be that the first item in the selection, or p if p comes before it) to the last item affected (be that one before the last item in the selection, or p if p comes after it). 
<p>Definition at line <a class="el" href="selection__algorithms_8hpp_source.html#l00866">866</a> of file <a class="el" href="selection__algorithms_8hpp_source.html">selection_algorithms.hpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="g22b88fa69cfe4fa510a78596d4db07ad"></a><!-- doxytag: member="adobe::selection_symmetric_difference" ref="g22b88fa69cfe4fa510a78596d4db07ad" args="(const Selection1 &amp;x, const Selection2 &amp;y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Selection1 adobe::selection_symmetric_difference           </td>
          <td>(</td>
          <td class="paramtype">const Selection1 &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Selection2 &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
selection_symmetric_difference implementation 
<p>

<p>Definition at line <a class="el" href="selection__algorithms_8hpp_source.html#l00394">394</a> of file <a class="el" href="selection__algorithms_8hpp_source.html">selection_algorithms.hpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="g2b8d3fe6f353246974f3fc8641c9640f"></a><!-- doxytag: member="adobe::selection_symmetric_difference" ref="g2b8d3fe6f353246974f3fc8641c9640f" args="(S1 s1_first, S1 s1_last, S2 s2_first, S2 s2_last, O output, C comp, bool s1_inside=false, bool s2_inside=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">O adobe::selection_symmetric_difference           </td>
          <td>(</td>
          <td class="paramtype">S1&nbsp;</td>
          <td class="paramname"> <em>s1_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S1&nbsp;</td>
          <td class="paramname"> <em>s1_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S2&nbsp;</td>
          <td class="paramname"> <em>s2_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S2&nbsp;</td>
          <td class="paramname"> <em>s2_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O&nbsp;</td>
          <td class="paramname"> <em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&nbsp;</td>
          <td class="paramname"> <em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>s1_inside</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>s2_inside</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
selection_symmetric_difference implementation 
<p>

<p>Definition at line <a class="el" href="selection__algorithms_8hpp_source.html#l00253">253</a> of file <a class="el" href="selection__algorithms_8hpp_source.html">selection_algorithms.hpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="ga1b7513dba97d3b2447fd2ea35c8f0e2"></a><!-- doxytag: member="adobe::selection_to_index_set" ref="ga1b7513dba97d3b2447fd2ea35c8f0e2" args="(const Selection &amp;selection, typename boost::range_size&lt; Selection &gt;::type max_index, OutputIterator output)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator adobe::selection_to_index_set           </td>
          <td>(</td>
          <td class="paramtype">const Selection &amp;&nbsp;</td>
          <td class="paramname"> <em>selection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename boost::range_size&lt; Selection &gt;::type&nbsp;</td>
          <td class="paramname"> <em>max_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&nbsp;</td>
          <td class="paramname"> <em>output</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Takes a set of indices and converts them to a boundary-based Selection 
<p>Definition at line <a class="el" href="selection__algorithms_8hpp_source.html#l00934">934</a> of file <a class="el" href="selection__algorithms_8hpp_source.html">selection_algorithms.hpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="ga2f8f3bba5b11918f0838b727a4d7076"></a><!-- doxytag: member="adobe::selection_union" ref="ga2f8f3bba5b11918f0838b727a4d7076" args="(const Selection1 &amp;x, const Selection2 &amp;y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Selection1 adobe::selection_union           </td>
          <td>(</td>
          <td class="paramtype">const Selection1 &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Selection2 &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
selection_union implementation 
<p>

<p>Definition at line <a class="el" href="selection__algorithms_8hpp_source.html#l00346">346</a> of file <a class="el" href="selection__algorithms_8hpp_source.html">selection_algorithms.hpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="g7d151d2d10f526bacd2264accb8198ad"></a><!-- doxytag: member="adobe::selection_union" ref="g7d151d2d10f526bacd2264accb8198ad" args="(S1 s1_first, S1 s1_last, S2 s2_first, S2 s2_last, O output, C comp, bool s1_inside=false, bool s2_inside=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">O adobe::selection_union           </td>
          <td>(</td>
          <td class="paramtype">S1&nbsp;</td>
          <td class="paramname"> <em>s1_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S1&nbsp;</td>
          <td class="paramname"> <em>s1_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S2&nbsp;</td>
          <td class="paramname"> <em>s2_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S2&nbsp;</td>
          <td class="paramname"> <em>s2_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O&nbsp;</td>
          <td class="paramname"> <em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&nbsp;</td>
          <td class="paramname"> <em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>s1_inside</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>s2_inside</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
selection_union implementation 
<p>

<p>Definition at line <a class="el" href="selection__algorithms_8hpp_source.html#l00170">170</a> of file <a class="el" href="selection__algorithms_8hpp_source.html">selection_algorithms.hpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="ge260f209173f7775b87df5c4ee3b68c2"></a><!-- doxytag: member="adobe::size" ref="ge260f209173f7775b87df5c4ee3b68c2" args="(const Selection &amp;x, const ForwardRange &amp;range)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::range_size&lt;Selection&gt;::type adobe::size           </td>
          <td>(</td>
          <td class="paramtype">const Selection &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ForwardRange &amp;&nbsp;</td>
          <td class="paramname"> <em>range</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Given a container, returns the number of elements selected by the selection <code>x</code>. </dd></dl>

<p>Definition at line <a class="el" href="selection__algorithms_8hpp_source.html#l00467">467</a> of file <a class="el" href="selection__algorithms_8hpp_source.html">selection_algorithms.hpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="g7c5bdb55e42beda2cd6acbe643ef4fa2"></a><!-- doxytag: member="adobe::size" ref="g7c5bdb55e42beda2cd6acbe643ef4fa2" args="(const Selection &amp;x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::range_size&lt;Selection&gt;::type adobe::size           </td>
          <td>(</td>
          <td class="paramtype">const Selection &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the number of selection boundaries present in <code>x</code>. </dd></dl>

<p>Definition at line <a class="el" href="selection__algorithms_8hpp_source.html#l00457">457</a> of file <a class="el" href="selection__algorithms_8hpp_source.html">selection_algorithms.hpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="g3c24719c51126b824d063b9caec4d3c6"></a><!-- doxytag: member="adobe::start_selected" ref="g3c24719c51126b824d063b9caec4d3c6" args="(const Selection &amp;x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool adobe::start_selected           </td>
          <td>(</td>
          <td class="paramtype">const Selection &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
start_selected implementation 
<p>

<p>Definition at line <a class="el" href="selection__algorithms_8hpp_source.html#l00447">447</a> of file <a class="el" href="selection__algorithms_8hpp_source.html">selection_algorithms.hpp</a>.</p>

</div>
</div><p>
</div>

<!-- Begin Footer -->
</td></tr>
</table>
</div> <!-- content -->
<div class='footerdiv'>
    <div id='footersub'>
        <ul>
            <li><a href="http://www.adobe.com/go/gftray_foot_aboutadobe">Company</a>&nbsp;|&nbsp;</li>
            <li><a href="http://www.adobe.com/go/gftray_foot_privacy_security">Online Privacy Policy</a>&nbsp;|&nbsp;</li>
            <li><a href="http://www.adobe.com/go/gftray_foot_terms">Terms of Use</a>&nbsp;|&nbsp;</li>
    
            <li><a href="http://www.adobe.com/go/gftray_foot_contact_adobe">Contact Us</a>&nbsp;|&nbsp;</li>
            <li><a href="http://www.adobe.com/go/gftray_foot_accessibility">Accessibility</a>&nbsp;|&nbsp;</li>
            <li><a href="http://www.adobe.com/go/gftray_foot_report_piracy">Report Piracy</a>&nbsp;|&nbsp;</li>
            <li><a href="http://www.adobe.com/go/gftray_foot_permissions_trademarks">Permissions &amp; Trademarks</a>&nbsp;|&nbsp;</li>
            <li><a href="http://www.adobe.com/go/gftray_foot_product_license_agreements">Product License Agreements</a>&nbsp;|&nbsp;</li>
    
            <li><a href="http://www.adobe.com/go/gftray_foot_feedback">Send Feedback</a></li>
        </ul>
        <div>
            <p>Copyright &#169; 2006-2007 Adobe Systems Incorporated.</p>
            <p>Use of this website signifies your agreement to the <a href="http://www.adobe.com/go/gftray_foot_terms">Terms of Use</a> and <a href="http://www.adobe.com/go/gftray_foot_privacy_security">Online Privacy Policy</a>.</p>
            <p>Search powered by <a href="http://www.google.com/" target="new">Google</a></p>
        </div>
	</div>
</div>
<script type="text/javascript">
_uacct = "UA-396569-1";
urchinTracker();
</script>
</body>
</html>
