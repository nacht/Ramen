<!--
    Copyright 2005-2008 Adobe Systems Incorporated
    Distributed under the MIT License (see accompanying file LICENSE_1_0_0.txt
    or a copy at http://stlab.adobe.com/licenses.html)

    Some files are held under additional license.
    Please see "http://stlab.adobe.com/licenses.html" for more information.
-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
    <TITLE>Adobe Software Technology Lab: iterator_tags</TITLE>
    <META HTTP-EQUIV="content-type" CONTENT="text/html;charset=ISO-8859-1"/>
    <LINK TYPE="text/css" REL="stylesheet" HREF="adobe_source.css"/>
    <LINK REL="alternate" TITLE="stlab.adobe.com RSS" HREF="http://sourceforge.net/export/rss2_projnews.php?group_id=132417&amp;rss_fulltext=1" TYPE="application/rss+xml"/>
    <script src="http://www.google-analytics.com/urchin.js" type="text/javascript"></script>
</head>
<body>
<div id='content'>
<table><tr>
<td colspan='5'>
    <div id='opensource_banner'>
    <table style='width: 100%; padding: 5px;'><tr>
    <td align='left'>
        <a href='index.html' style='border: none'><img src='stlab2007.jpg' alt="stlab.adobe.com"/></a>
    </td>
    <td align='right'>
        <a href='http://www.adobe.com' style='border: none'><img src='adobe_hlogo.gif' alt="Adobe Systems Incorporated"/></a>
    </td>
    </tr></table>
    </div>
</td></tr><tr>
<td valign="top">
    <div id='navtable' height='100%'>
    <div style='margin: 5px'>
        <h4>Documentation</h4>

        <a href="group__asl__overview.html">Overview</a><br/>
        <a href="asl_readme.html">Building ASL</a><br/>
        <a href="asl_toc.html">Documentation</a><br/>
        <a href="http://stlab.adobe.com/wiki/index.php/Supplementary_ASL_Documentation">Library Wiki Docs</a><br/>
        <a href="asl_indices.html">Indices</a><br/>
        <a href="http://stlab.adobe.com/perforce/">Browse Perforce</a><br/>

        <h4>More Info</h4>

        <a href="asl_release_notes.html">Release Notes</a><br/>
        <a href="http://stlab.adobe.com/wiki/">Wiki</a><br/>
        <a href="asl_search.html">Site Search</a><br/>
        <a href="licenses.html">License</a><br/>
        <a href="success_stories.html">Success Stories</a><br/>
        <a href="asl_contributors.html">Contributors</a><br/>

        <h4>Media</h4>

        <a href="http://sourceforge.net/project/showfiles.php?group_id=132417&amp;package_id=145420">Download</a><br/>
        <a href="asl_download_perforce.html">Perforce Depots</a><br/>

        <h4>Support</h4>

        <a href="http://sourceforge.net/projects/adobe-source/">ASL SourceForge Home</a><br/>
        <a href="http://sourceforge.net/mail/?group_id=132417">Mailing Lists</a><br/>
        <a href="http://sourceforge.net/forum/?group_id=132417">Discussion Forums</a><br/>
        <a href="http://sourceforge.net/tracker/?atid=724218&amp;group_id=132417&amp;func=browse">Report Bugs</a><br/>
        <a href="http://sourceforge.net/tracker/?atid=724221&amp;group_id=132417&amp;func=browse">Suggest Features</a><br/>
        <a href="asl_contributing.html">Contribute to ASL</a><br/>

        <h4>RSS</h4>

        <a href="http://sourceforge.net/export/rss2_projnews.php?group_id=132417">Short-text news</a><br/>
        <a href="http://sourceforge.net/export/rss2_projnews.php?group_id=132417&amp;rss_fulltext=1">Full-text news</a><br/>
        <a href="http://sourceforge.net/export/rss2_projfiles.php?group_id=132417">File releases</a><br/>

        <h4>Other Adobe Projects</h4>

        <a href="adobe_apollo.html">Adobe Air</a><br/>
        <a href="http://stlab.adobe.com/gil/">Adobe GIL</a><br/>
        <a href="http://stlab.adobe.com/performance/">C++ Benchmarks</a><br/>
        <a href="http://labs.adobe.com">Adobe Labs</a><br/>
        <a href="http://stlab.adobe.com/amg/">Adobe Media Gallery</a><br/>
        <a href="http://www.adobe.com/products/xmp/">Adobe XMP</a><br/>
        <a href="http://www.mozilla.org/projects/tamarin">Tamarin project<br/>(Mozilla Foundation)</a><br/>

        <h4>Other Resources</h4>

        <a href="http://boost.org">Boost</a><br/>
        <a href="http://www.riaforge.com/">RIAForge</a><br/>
        <a href="http://www.sgi.com/tech/stl">SGI STL</a><br/>
    </div>
    </div>
</td>
<td id='maintable' width="100%" valign="top">

<!-- End Header -->
<!-- Generated by Doxygen 1.5.9 -->
<div class="contents">
<h1><a class="anchor" name="stldoc_iterator_tags">iterator_tags </a></h1><table cellpadding="0" cellspacing="0" width="100%" border="0">
<tr>
<td align="left"><div align="center">
<img src="iterators.gif" alt="iterators.gif">
</div>
 </td><td width="100%"></td><td align="right"><div align="center">
<img src="overview.gif" alt="overview.gif">
</div>
  </td></tr>
<tr>
<td align="left" valign="top"><b>Category</b>: iterators </td><td width="100%"></td><td align="right" valign="top"><b>Component type</b>: overview  </td></tr>
</table>
<h2><a class="anchor" name="Summary">
Summary</a></h2>
Iterator tag functions are a method for accessing information that is associated with iterators. Specifically, an iterator type must, as discussed in the <a class="el" href="stldoc_InputIterator.html">InputIterator</a> requirements, have an associated <em>distance type</em> and <em>value type</em>. <a href="#1">[1]</a> It is sometimes important for an algorithm parameterized by an iterator type to be able to determine the distance type and value type. Iterator tags also allow algorithms to determine an iterator's category, so that they can take different actions depending on whether an iterator is an <a class="el" href="stldoc_InputIterator.html">InputIterator</a>, <a class="el" href="stldoc_OutputIterator.html">OutputIterator</a>, <a class="el" href="stldoc_ForwardIterator.html">ForwardIterator</a>, <a class="el" href="stldoc_BidirectionalIterator.html">BidirectionalIterator</a>, or <a class="el" href="stldoc_RandomAccessIterator.html">RandomAccessIterator</a>. <p>
Note that the iterator tag functions <code><a class="el" href="stldoc_distance_type.html">distance_type</a></code>, <code><a class="el" href="stldoc_value_type.html">value_type</a></code>, and <code><a class="el" href="stldoc_iterator_category.html">iterator_category</a></code> are an older method of accessing the type information associated with iterators: they were defined in the original STL. The draft C++ standard, however, defines a different and more convenient mechanism: <code><a class="el" href="stldoc_iterator_traits.html">iterator_traits</a></code>. Both mechanisms are supported <a href="#2">[2]</a>, for reasons of backwards compatibility, but the older mechanism will eventually be removed. <h2><a class="anchor" name="Description">
Description</a></h2>
The basic idea of the iterator tag functions, and of <code><a class="el" href="stldoc_iterator_traits.html">iterator_traits</a></code>, is quite simple: iterators have associated type information, and there must be a way to access that information. Specifically, iterator tag functions and <code><a class="el" href="stldoc_iterator_traits.html">iterator_traits</a></code> are used to determine an iterator's value type, distance type, and iterator category. <p>
An iterator's <em>category</em> is the most specific concept that it is a model of: <a class="el" href="stldoc_InputIterator.html">InputIterator</a>, <a class="el" href="stldoc_OutputIterator.html">OutputIterator</a>, <a class="el" href="stldoc_ForwardIterator.html">ForwardIterator</a>, <a class="el" href="stldoc_BidirectionalIterator.html">BidirectionalIterator</a>, or <a class="el" href="stldoc_RandomAccessIterator.html">RandomAccessIterator</a>. This information is expressed in the C++ type system by defining five category tag types, <code><a class="el" href="stldoc_input_iterator_tag.html">input_iterator_tag</a></code>, <code><a class="el" href="stldoc_output_iterator_tag.html">output_iterator_tag</a></code>, <code><a class="el" href="stldoc_forward_iterator_tag.html">forward_iterator_tag</a></code>, <code><a class="el" href="stldoc_bidirectional_iterator_tag.html">bidirectional_iterator_tag</a></code>, and <code><a class="el" href="stldoc_random_access_iterator_tag.html">random_access_iterator_tag</a></code>, each of which corresponds to one of those concepts. <a href="#3">[3]</a> <p>
The function <code><a class="el" href="stldoc_iterator_category.html">iterator_category</a></code> takes a single argument, an iterator, and returns the tag corresponding to that iterator's category. That is, it returns a <code><a class="el" href="stldoc_random_access_iterator_tag.html">random_access_iterator_tag</a></code> if its argument is a pointer, a <code><a class="el" href="stldoc_bidirectional_iterator_tag.html">bidirectional_iterator_tag</a></code> if its argument is a <code>List::iterator</code>, and so on. <code>Iterator_traits</code> provides the same information in a slightly different way: if <code>I</code> is an iterator, then <code><a class="el" href="stldoc_iterator_traits.html">iterator_traits</a>&lt;I&gt;iterator_category</code> is a nested <code>typedef</code>: it is one of the five category tag types. <p>
An iterator's <em>value type</em> is the type of object that is returned when the iterator is dereferenced. (See the discussion in the <a class="el" href="stldoc_InputIterator.html">InputIterator</a> requirements.) Ideally, one might want <code><a class="el" href="stldoc_value_type.html">value_type</a></code> to take a single argument, an iterator, and return the iterator's value type. Unfortunately, that's impossible: a function must return an object, and types aren't objects. Instead, <code><a class="el" href="stldoc_value_type.html">value_type</a></code> returns the value <code>(T*) 0</code>, where <code>T</code> is the argument's value type. The <code>iterator_traits</code> class, however, does not have this restriction: <code>iterator_traits&lt;I&gt;value_type</code> is a type, not a value. It is a nested <code>typedef</code>, and it can be used in declarations of variables, as an function's argument type or return type, and in any other ways that C++ types can be used. <p>
(Note that the function <code><a class="el" href="stldoc_value_type.html">value_type</a></code> need not be defined for <a class="el" href="stldoc_OutputIterator.html">OutputIterator</a>, since an <a class="el" href="stldoc_OutputIterator.html">OutputIterator</a> need not have a value type. Similarly, <code><a class="el" href="stldoc_iterator_traits.html">iterator_traits</a>&lt;I&gt;value_type</code> is typically defined as <code>void</code> when <code>I</code> is an output iterator) <p>
An iterator's <em>distance type</em>, or <em>difference type</em> (the terms are synonymous) is the type that is used to represent the distance between two iterators. (See the discussion in the <a class="el" href="stldoc_InputIterator.html">InputIterator</a> requirements.) The function <code><a class="el" href="stldoc_distance_type.html">distance_type</a></code> returns this information in the same form that <code><a class="el" href="stldoc_value_type.html">value_type</a></code> does: its argument is an iterator, and it returns the value <code>(Distance*) 0</code>, where <code>Distance</code> is the iterator's distance type. Similarly, <code><a class="el" href="stldoc_iterator_traits.html">iterator_traits</a>&lt;I&gt;difference_type</code> is <code>I</code>'s distance type. <p>
Just as with <code><a class="el" href="stldoc_value_type.html">value_type</a></code>, the function <code><a class="el" href="stldoc_distance_type.html">distance_type</a></code> need not be defined for <a class="el" href="stldoc_OutputIterator.html">OutputIterator</a>, and, if <code>I</code> is an <a class="el" href="stldoc_OutputIterator.html">OutputIterator</a>, <code><a class="el" href="stldoc_iterator_traits.html">iterator_traits</a>&lt;I&gt;difference_type</code> may be defined as <code>void</code>. An <a class="el" href="stldoc_OutputIterator.html">OutputIterator</a> need not have a distance type. <p>
The functions <code><a class="el" href="stldoc_iterator_category.html">iterator_category</a></code>, <code><a class="el" href="stldoc_value_type.html">value_type</a></code>, and <code><a class="el" href="stldoc_distance_type.html">distance_type</a></code> must be provided for every type of iterator. (Except, as noted above, that <code><a class="el" href="stldoc_value_type.html">value_type</a></code> and <code><a class="el" href="stldoc_distance_type.html">distance_type</a></code> need not be provided for <a class="el" href="stldoc_OutputIterator.html">OutputIterator</a>.) In principle, this is simply a matter of overloading: anyone who defines a new iterator type must define those three functions for it. In practice, there's a slightly more convenient method. The STL defines five base classes, <code><a class="el" href="stldoc_output_iterator.html">output_iterator</a></code>, <code><a class="el" href="stldoc_input_iterator.html">input_iterator</a></code>, <code><a class="el" href="stldoc_forward_iterator.html">forward_iterator</a></code>, <code><a class="el" href="stldoc_bidirectional_iterator.html">bidirectional_iterator</a></code>, and <code><a class="el" href="stldoc_random_access_iterator.html">random_access_iterator</a></code>. The functions <code><a class="el" href="stldoc_iterator_category.html">iterator_category</a></code>, <code><a class="el" href="stldoc_value_type.html">value_type</a></code>, and <code><a class="el" href="stldoc_distance_type.html">distance_type</a></code> are defined for those base classes. The effect, then, is that if you are defining a new type of iterator you can simply derive it from one of those base classes, and the iterator tag functions will automatically be defined correctly. These base classes contain no member functions or member variables, so deriving from one of them ought not to incur any overhead. <p>
(Again, note that base classes are provided solely for the convenience of people who define iterators. If you define a class <code>Iter</code> that is a new kind of <a class="el" href="stldoc_BidirectionalIterator.html">BidirectionalIterator</a>, you do not have to derive it from the base class <code><a class="el" href="stldoc_bidirectional_iterator.html">bidirectional_iterator</a></code>. You do, however, have to make sure that <code><a class="el" href="stldoc_iterator_category.html">iterator_category</a></code>, <code><a class="el" href="stldoc_value_type.html">value_type</a></code>, and <code><a class="el" href="stldoc_distance_type.html">distance_type</a></code> are defined correctly for arguments of type <code>Iter</code>, and deriving <code>Iter</code> from <code><a class="el" href="stldoc_bidirectional_iterator.html">bidirectional_iterator</a></code> is usually the most convenient way to do that.) <h2><a class="anchor" name="Examples">
Examples</a></h2>
This example uses the <code><a class="el" href="stldoc_value_type.html">value_type</a></code> iterator tag function in order to declare a temporary variable of an iterator's value type. Note the use of an auxiliary function, <code>__iter_swap</code>. This is a very common idiom: most uses of iterator tags involve auxiliary functions. <div class="fragment"><pre class="fragment">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> ForwardIterator1, <span class="keyword">class</span> ForwardIterator2, <span class="keyword">class</span> ValueType&gt;
    <span class="keyword">inline</span> <span class="keywordtype">void</span> __iter_swap(ForwardIterator1 a, ForwardIterator2 b, ValueType*) {
    ValueType tmp = *a;
    *a = *b;
    *b = tmp;
    }

    <span class="keyword">template</span> &lt;<span class="keyword">class</span> ForwardIterator1, <span class="keyword">class</span> ForwardIterator2&gt;
    <span class="keyword">inline</span> <span class="keywordtype">void</span> iter_swap(ForwardIterator1 a, ForwardIterator2 b) {
    __iter_swap(a, b, value_type(a));
    }
</pre></div> <p>
This example does exactly the same thing, using <code><a class="el" href="stldoc_iterator_traits.html">iterator_traits</a></code> instead. Note how much simpler it is: the auxiliary function is no longer required. <div class="fragment"><pre class="fragment">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> ForwardIterator1, <span class="keyword">class</span> ForwardIterator2&gt;
    <span class="keyword">inline</span> <span class="keywordtype">void</span> iter_swap(ForwardIterator1 a, ForwardIterator2 b) {
        iterator_traits&lt;ForwardIterator1&gt;::value_type tmp = *a;
        *a = *b;
        *b = tmp;    
    }
</pre></div> <p>
This example uses the <code><a class="el" href="stldoc_iterator_category.html">iterator_category</a></code> iterator tag function: <code><a class="el" href="stldoc_reverse.html">reverse</a></code> can be implemented for either <a class="el" href="stldoc_BidirectionalIterator.html">BidirectionalIterator</a> or for <a class="el" href="stldoc_RandomAccessIterator.html">RandomAccessIterator</a>, but the algorithm for <a class="el" href="stldoc_RandomAccessIterator.html">RandomAccessIterator</a> is more efficient. Consequently, <code><a class="el" href="stldoc_reverse.html">reverse</a></code> is written to dispatch on the iterator category. This dispatch takes place at compile time, and should not incur any run-time penalty. <div class="fragment"><pre class="fragment">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> B<span class="keywordtype">id</span>irectionalIterator&gt;
    <span class="keywordtype">void</span> __reverse(BidirectionalIterator first, BidirectionalIterator last, 
           bidirectional_iterator_tag) {
    <span class="keywordflow">while</span> (<span class="keyword">true</span>)
        <span class="keywordflow">if</span> (first == last || first == --last)
        <span class="keywordflow">return</span>;
        <span class="keywordflow">else</span>
        iter_swap(first++, last);
    }

    <span class="keyword">template</span> &lt;<span class="keyword">class</span> RandomAccessIterator&gt;
    <span class="keywordtype">void</span> __reverse(RandomAccessIterator first, RandomAccessIterator last,
           random_access_iterator_tag) {
    <span class="keywordflow">while</span> (first &lt; last) iter_swap(first++, --last);
    }

    <span class="keyword">template</span> &lt;<span class="keyword">class</span> B<span class="keywordtype">id</span>irectionalIterator&gt;
    <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="group__reverse.html#g78a6855b85b846ac09dabd77012080b8" title="reverse implementation">reverse</a>(BidirectionalIterator first, BidirectionalIterator last) {
    __reverse(first, last, iterator_category(first));
    }
</pre></div> <p>
In this case, <code><a class="el" href="stldoc_iterator_traits.html">iterator_traits</a></code> would not be different in any substantive way: it would still be necessary to use auxiliary functions to dispatch on the iterator category. The only difference is changing the top-level function to <div class="fragment"><pre class="fragment">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> B<span class="keywordtype">id</span>irectionalIterator&gt;
    <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="group__reverse.html#g78a6855b85b846ac09dabd77012080b8" title="reverse implementation">reverse</a>(BidirectionalIterator first, BidirectionalIterator last) {
    __reverse(first, last, 
                  iterator_traits&lt;first&gt;::iterator_category());
    }
</pre></div> <h2><a class="anchor" name="Concepts">
Concepts</a></h2>
<h2><a class="anchor" name="Types">
Types</a></h2>
<ul>
<li>
<code><a class="el" href="stldoc_output_iterator.html">output_iterator</a></code> </li>
<li>
<code><a class="el" href="stldoc_input_iterator.html">input_iterator</a></code> </li>
<li>
<code><a class="el" href="stldoc_forward_iterator.html">forward_iterator</a></code> </li>
<li>
<code><a class="el" href="stldoc_bidirectional_iterator.html">bidirectional_iterator</a></code> </li>
<li>
<code><a class="el" href="stldoc_random_access_iterator.html">random_access_iterator</a></code> </li>
</ul>
<ul>
<li>
<code><a class="el" href="stldoc_output_iterator_tag.html">output_iterator_tag</a></code> </li>
<li>
<code><a class="el" href="stldoc_input_iterator_tag.html">input_iterator_tag</a></code> </li>
<li>
<code><a class="el" href="stldoc_forward_iterator_tag.html">forward_iterator_tag</a></code> </li>
<li>
<code><a class="el" href="stldoc_bidirectional_iterator_tag.html">bidirectional_iterator_tag</a></code> </li>
<li>
<code><a class="el" href="stldoc_random_access_iterator_tag.html">random_access_iterator_tag</a></code> </li>
</ul>
<ul>
<li>
<code><a class="el" href="stldoc_iterator_traits.html">iterator_traits</a></code> </li>
</ul>
<h2><a class="anchor" name="Functions">
Functions</a></h2>
<ul>
<li>
<code><a class="el" href="stldoc_iterator_category.html">iterator_category</a></code> </li>
<li>
<code><a class="el" href="stldoc_value_type.html">value_type</a></code> </li>
<li>
<code><a class="el" href="stldoc_distance_type.html">distance_type</a></code> </li>
</ul>
<h2><a class="anchor" name="Notes">
Notes</a></h2>
<a class="anchor" name="1"></a>[1] <a class="el" href="stldoc_OutputIterator.html">OutputIterator</a> have neither a distance type nor a value type; in many ways, in fact, <a class="el" href="stldoc_OutputIterator.html">OutputIterator</a> aren't really iterators. Output iterators do not have a value type, because it is impossible to obtain a value from an output iterator but only to write a value through it. They do not have a distance type, similarly, because it is impossible to find the distance from one output iterator to another. Finding a distance requires a comparison for equality, and output iterators do not support <code>operator==</code>. <p>
<a class="anchor" name="2"></a>[2] The <code><a class="el" href="stldoc_iterator_traits.html">iterator_traits</a></code> class relies on a C++ feature known as <em>partial specialization</em>. Many of today's compilers don't implement the complete standard; in particular, many compilers do not support partial specialization. If your compiler does not support partial specialization, then you will not be able to use <code><a class="el" href="stldoc_iterator_traits.html">iterator_traits</a></code>, and you will have to continue to use the older iterator tag functions. <p>
<a class="anchor" name="3"></a>[3] Note that <a class="el" href="stldoc_trivial.html">trivial</a> does not appear in this list. The <a class="el" href="stldoc_trivial.html">trivial</a> concept is introduced solely for conceptual clarity; the STL does not actually define any <a class="el" href="stldoc_trivial.html">trivial</a> types, so there is no need for a <a class="el" href="stldoc_trivial.html">trivial</a> tag. There is, in fact, a strong reason not to define one: the C++ type system does not provide any way to distinguish between a pointer that is being used as a trivial iterator (that is, a pointer to an object that isn't part of an array) and a pointer that is being used as a <a class="el" href="stldoc_RandomAccessIterator.html">RandomAccessIterator</a> into an array. <h2><a class="anchor" name="See_also">
See also</a></h2>
<a class="el" href="stldoc_InputIterator.html">InputIterator</a>, <a class="el" href="stldoc_OutputIterator.html">OutputIterator</a>, <a class="el" href="stldoc_ForwardIterator.html">ForwardIterator</a>, <a class="el" href="stldoc_BidirectionalIterator.html">BidirectionalIterator</a>, <a class="el" href="stldoc_RandomAccessIterator.html">RandomAccessIterator</a>, <code><a class="el" href="stldoc_iterator_traits.html">iterator_traits</a></code>, <a class="el" href="stldoc_Iterators.html">Iterators</a> </div>

<!-- Begin Footer -->
</td></tr>
</table>
</div> <!-- content -->
<div class='footerdiv'>
    <div id='footersub'>
        <ul>
            <li><a href="http://www.adobe.com/go/gftray_foot_aboutadobe">Company</a>&nbsp;|&nbsp;</li>
            <li><a href="http://www.adobe.com/go/gftray_foot_privacy_security">Online Privacy Policy</a>&nbsp;|&nbsp;</li>
            <li><a href="http://www.adobe.com/go/gftray_foot_terms">Terms of Use</a>&nbsp;|&nbsp;</li>
    
            <li><a href="http://www.adobe.com/go/gftray_foot_contact_adobe">Contact Us</a>&nbsp;|&nbsp;</li>
            <li><a href="http://www.adobe.com/go/gftray_foot_accessibility">Accessibility</a>&nbsp;|&nbsp;</li>
            <li><a href="http://www.adobe.com/go/gftray_foot_report_piracy">Report Piracy</a>&nbsp;|&nbsp;</li>
            <li><a href="http://www.adobe.com/go/gftray_foot_permissions_trademarks">Permissions &amp; Trademarks</a>&nbsp;|&nbsp;</li>
            <li><a href="http://www.adobe.com/go/gftray_foot_product_license_agreements">Product License Agreements</a>&nbsp;|&nbsp;</li>
    
            <li><a href="http://www.adobe.com/go/gftray_foot_feedback">Send Feedback</a></li>
        </ul>
        <div>
            <p>Copyright &#169; 2006-2007 Adobe Systems Incorporated.</p>
            <p>Use of this website signifies your agreement to the <a href="http://www.adobe.com/go/gftray_foot_terms">Terms of Use</a> and <a href="http://www.adobe.com/go/gftray_foot_privacy_security">Online Privacy Policy</a>.</p>
            <p>Search powered by <a href="http://www.google.com/" target="new">Google</a></p>
        </div>
	</div>
</div>
<script type="text/javascript">
_uacct = "UA-396569-1";
urchinTracker();
</script>
</body>
</html>
