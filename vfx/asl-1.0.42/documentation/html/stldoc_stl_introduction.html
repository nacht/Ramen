<!--
    Copyright 2005-2008 Adobe Systems Incorporated
    Distributed under the MIT License (see accompanying file LICENSE_1_0_0.txt
    or a copy at http://stlab.adobe.com/licenses.html)

    Some files are held under additional license.
    Please see "http://stlab.adobe.com/licenses.html" for more information.
-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
    <TITLE>Adobe Software Technology Lab: Introduction to the Standard Template Library</TITLE>
    <META HTTP-EQUIV="content-type" CONTENT="text/html;charset=ISO-8859-1"/>
    <LINK TYPE="text/css" REL="stylesheet" HREF="adobe_source.css"/>
    <LINK REL="alternate" TITLE="stlab.adobe.com RSS" HREF="http://sourceforge.net/export/rss2_projnews.php?group_id=132417&amp;rss_fulltext=1" TYPE="application/rss+xml"/>
    <script src="http://www.google-analytics.com/urchin.js" type="text/javascript"></script>
</head>
<body>
<div id='content'>
<table><tr>
<td colspan='5'>
    <div id='opensource_banner'>
    <table style='width: 100%; padding: 5px;'><tr>
    <td align='left'>
        <a href='index.html' style='border: none'><img src='stlab2007.jpg' alt="stlab.adobe.com"/></a>
    </td>
    <td align='right'>
        <a href='http://www.adobe.com' style='border: none'><img src='adobe_hlogo.gif' alt="Adobe Systems Incorporated"/></a>
    </td>
    </tr></table>
    </div>
</td></tr><tr>
<td valign="top">
    <div id='navtable' height='100%'>
    <div style='margin: 5px'>
        <h4>Documentation</h4>

        <a href="group__asl__overview.html">Overview</a><br/>
        <a href="asl_readme.html">Building ASL</a><br/>
        <a href="asl_toc.html">Documentation</a><br/>
        <a href="http://stlab.adobe.com/wiki/index.php/Supplementary_ASL_Documentation">Library Wiki Docs</a><br/>
        <a href="asl_indices.html">Indices</a><br/>
        <a href="http://stlab.adobe.com/perforce/">Browse Perforce</a><br/>

        <h4>More Info</h4>

        <a href="asl_release_notes.html">Release Notes</a><br/>
        <a href="http://stlab.adobe.com/wiki/">Wiki</a><br/>
        <a href="asl_search.html">Site Search</a><br/>
        <a href="licenses.html">License</a><br/>
        <a href="success_stories.html">Success Stories</a><br/>
        <a href="asl_contributors.html">Contributors</a><br/>

        <h4>Media</h4>

        <a href="http://sourceforge.net/project/showfiles.php?group_id=132417&amp;package_id=145420">Download</a><br/>
        <a href="asl_download_perforce.html">Perforce Depots</a><br/>

        <h4>Support</h4>

        <a href="http://sourceforge.net/projects/adobe-source/">ASL SourceForge Home</a><br/>
        <a href="http://sourceforge.net/mail/?group_id=132417">Mailing Lists</a><br/>
        <a href="http://sourceforge.net/forum/?group_id=132417">Discussion Forums</a><br/>
        <a href="http://sourceforge.net/tracker/?atid=724218&amp;group_id=132417&amp;func=browse">Report Bugs</a><br/>
        <a href="http://sourceforge.net/tracker/?atid=724221&amp;group_id=132417&amp;func=browse">Suggest Features</a><br/>
        <a href="asl_contributing.html">Contribute to ASL</a><br/>

        <h4>RSS</h4>

        <a href="http://sourceforge.net/export/rss2_projnews.php?group_id=132417">Short-text news</a><br/>
        <a href="http://sourceforge.net/export/rss2_projnews.php?group_id=132417&amp;rss_fulltext=1">Full-text news</a><br/>
        <a href="http://sourceforge.net/export/rss2_projfiles.php?group_id=132417">File releases</a><br/>

        <h4>Other Adobe Projects</h4>

        <a href="adobe_apollo.html">Adobe Air</a><br/>
        <a href="http://stlab.adobe.com/gil/">Adobe GIL</a><br/>
        <a href="http://stlab.adobe.com/performance/">C++ Benchmarks</a><br/>
        <a href="http://labs.adobe.com">Adobe Labs</a><br/>
        <a href="http://stlab.adobe.com/amg/">Adobe Media Gallery</a><br/>
        <a href="http://www.adobe.com/products/xmp/">Adobe XMP</a><br/>
        <a href="http://www.mozilla.org/projects/tamarin">Tamarin project<br/>(Mozilla Foundation)</a><br/>

        <h4>Other Resources</h4>

        <a href="http://boost.org">Boost</a><br/>
        <a href="http://www.riaforge.com/">RIAForge</a><br/>
        <a href="http://www.sgi.com/tech/stl">SGI STL</a><br/>
    </div>
    </div>
</td>
<td id='maintable' width="100%" valign="top">

<!-- End Header -->
<!-- Generated by Doxygen 1.5.9 -->
<div class="contents">
<h1><a class="anchor" name="stldoc_stl_introduction">Introduction to the Standard Template Library </a></h1>The Standard Template Library, or <em>STL</em>, is a C++ library of container classes, algorithms, and iterators; it provides many of the basic algorithms and data structures of computer science. The STL is a <em>generic</em> library, meaning that its components are heavily parameterized: almost every component in the STL is a template. You should make sure that you understand how templates work in C++ before you use the STL. <h2>Containers and algorithms</h2>
<p>
Like many class libraries, the STL includes <em>container</em> classes: classes whose purpose is to contain other objects. The STL includes the classes <code><a class="el" href="stldoc_Vector.html">Vector</a></code>, <code><a class="el" href="stldoc_List.html">List</a></code>, <code><a class="el" href="stldoc_Deque.html">Deque</a></code>, <code><a class="el" href="stldoc_set.html">set</a></code>, <code><a class="el" href="stldoc_multiset.html">multiset</a></code>, <code><a class="el" href="stldoc_Map.html">Map</a></code>, <code><a class="el" href="stldoc_Multimap.html">Multimap</a></code>, <code><a class="el" href="stldoc_hash_set.html">hash_set</a></code>, <code><a class="el" href="stldoc_hash_multiset.html">hash_multiset</a></code>, <code><a class="el" href="stldoc_hash_map.html">hash_map</a></code>, and <code><a class="el" href="stldoc_hash_multimap.html">hash_multimap</a></code>. Each of these classes is a template, and can be instantiated to contain any type of object. You can, for example, use a <code>vector&lt;int&gt;</code> in much the same way as you would use an ordinary C array, except that <code>vector</code> eliminates the chore of managing dynamic memory allocation by hand. <div class="fragment"><pre class="fragment">      vector&lt;int&gt; v(3);            <span class="comment">// Declare a vector of 3 elements.</span>
      v[0] = 7;
      v[1] = v[0] + 3;
      v[2] = v[0] + v[1];          <span class="comment">// v[0] == 7, v[1] == 10, v[2] == 17  </span>
</pre></div> <p>
The STL also includes a large collection of <em>algorithms</em> that manipulate the data stored in containers. You can reverse the order of elements in a <code>vector</code>, for example, by using the <code><a class="el" href="stldoc_reverse.html">reverse</a></code> algorithm.  <div class="fragment"><pre class="fragment">      <a class="code" href="group__reverse.html#g78a6855b85b846ac09dabd77012080b8" title="reverse implementation">reverse</a>(v.begin(), v.end()); <span class="comment">// v[0] == 17, v[1] == 10, v[2] == 7</span>
</pre></div> <p>
There are two important points to notice about this call to <code>reverse</code>. First, it is a global function, not a member function. Second, it takes two arguments rather than one: it operates on a <em>range</em> of elements, rather than on a container. In this particular case the range happens to be the entire container <code>v.</code> <p>
The reason for both of these facts is the same: <code>reverse</code>, like other STL algorithms, is decoupled from the STL container classes. This means that <code>reverse</code> can be used not only to reverse elements in vectors, but also to reverse elements in lists, and even elements in C arrays. The following program is also valid. <div class="fragment"><pre class="fragment">      <span class="keywordtype">double</span> A[6] = { 1.2, 1.3, 1.4, 1.5, 1.6, 1.7 };
      <a class="code" href="group__reverse.html#g78a6855b85b846ac09dabd77012080b8" title="reverse implementation">reverse</a>(A, A + 6);
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 6; ++i)
        cout &lt;&lt; <span class="stringliteral">"A["</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">"] = "</span> &lt;&lt; A[i];
</pre></div> <p>
This example uses a <em>range</em>, just like the example of reversing a <code>vector</code>: the first argument to reverse is a pointer to the beginning of the range, and the second argument points one element past the end of the range. This range is denoted <code>[A, A + 6)</code>; the asymmetrical notation is a reminder that the two endpoints are different, that the first is the beginning of the range and the second is <em>one past</em> the end of the range.  <h2>Iterators</h2>
<p>
In the example of reversing a C array, the arguments to <code>reverse</code> are clearly of type <code>double*</code>. What are the arguments to reverse if you are reversing a <code>vector</code>, though, or a <code>list</code>? That is, what exactly does <code>reverse</code> declare its arguments to be, and what exactly do <code>v.begin()</code> and <code>v.end()</code> return?  <p>
The answer is that the arguments to <code>reverse</code> are <em>iterators</em>, which are a generalization of pointers. Pointers themselves are iterators, which is why it is possible to reverse the elements of a C array. Similarly, <code>vector</code> declares the nested types <code>iterator</code> and <code>const_iterator</code>. In the example above, the type returned by <code>v.begin()</code> and <code>v.end()</code> is <code>vector&lt;int&gt;iterator</code>. There are also some iterators, such as <code><a class="el" href="stldoc_istream_iterator.html">istream_iterator</a></code> and <code><a class="el" href="stldoc_ostream_iterator.html">ostream_iterator</a></code>, that aren't associated with containers at all.  <p>
Iterators are the mechanism that makes it possible to decouple algorithms from containers: algorithms are templates, and are parameterized by the type of iterator, so they are not restricted to a single type of container. Consider, for example, how to write an algorithm that performs linear search through a range. This is the STL's <code><a class="el" href="stldoc_find.html">find</a></code> algorithm.  <div class="fragment"><pre class="fragment">      <span class="keyword">template</span> &lt;<span class="keyword">class</span> InputIterator, <span class="keyword">class</span> T&gt;
      InputIterator <a class="code" href="group__find.html#g3ca10f4d1b45a1648140f00ef752bad3" title="find implementation">find</a>(InputIterator first, InputIterator last, <span class="keyword">const</span> T&amp; value) {
          <span class="keywordflow">while</span> (first != last &amp;&amp; *first != value) ++first;
          <span class="keywordflow">return</span> first;
      }
</pre></div> <p>
<code>Find</code> takes three arguments: two iterators that define a range, and a value to search for in that range. It examines each iterator in the range <code>[first, last)</code>, proceeding from the beginning to the end, and stops either when it finds an iterator that points to <code>value</code> or when it reaches the end of the range.  <p>
<code>First</code> and <code>last</code> are declared to be of type <code>InputIterator</code>, and <code>InputIterator</code> is a template parameter. That is, there isn't actually any type called <code>InputIterator</code>: when you call <code>find</code>, the compiler substitutes the actual type of the arguments for the formal type parameters <code>InputIterator</code> and <code>T</code>. If the first two arguments to <code>find</code> are of type <code>int*</code> and the third is of type <code>int</code>, then it is as if you had called the following function. <div class="fragment"><pre class="fragment">      <span class="keywordtype">int</span>* <a class="code" href="group__find.html#g3ca10f4d1b45a1648140f00ef752bad3" title="find implementation">find</a>(<span class="keywordtype">int</span>* first, <span class="keywordtype">int</span>* last, <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; value) {
          <span class="keywordflow">while</span> (first != last &amp;&amp; *first != value) ++first;
          <span class="keywordflow">return</span> first;
      }
</pre></div> <h2>Concepts and Modeling</h2>
<p>
One very important question to ask about any template function, not just about STL algorithms, is what the set of types is that may correctly be substituted for the formal template parameters. Clearly, for example, <code>int*</code> or <code>double*</code> may be substituted for <code>find</code>'s formal template parameter <code>InputIterator</code>. Equally clearly, <code>int</code> or <code>double</code> may not: <code>find</code> uses the expression <code>*first</code>, and the dereference operator makes no sense for an object of type <code>int</code> or of type <code>double</code>. The basic answer, then, is that <code>find</code> implicitly defines a set of requirements on types, and that it may be instantiated with any type that satisfies those requirements. Whatever type is substituted for <code>InputIterator</code> must provide certain operations: it must be possible to compare two objects of that type for equality, it must be possible to increment an object of that type, it must be possible to dereference an object of that type to obtain the object that it points to, and so on.  <p>
<code>Find</code> isn't the only STL algorithm that has such a set of requirements; the arguments to <code><a class="el" href="stldoc_for_each.html">for_each</a></code> and <code><a class="el" href="stldoc_count.html">count</a></code>, and other algorithms, must satisfy the same requirements. These requirements are sufficiently important that we give them a name: we call such a set of type requirements a <em>concept</em>, and we call this particular concept <b><a class="el" href="stldoc_InputIterator.html">InputIterator</a></b>. We say that a type <em>conforms to a concept</em>, or that it <em>is a model of a concept</em>, if it satisfies all of those requirements. We say that <code>int*</code> is a model of <b>Input Iterator</b> because <code>int*</code> provides all of the operations that are specified by the <b>Input Iterator</b> requirements.  <p>
Concepts are not a part of the C++ language; there is no way to declare a concept in a program, or to declare that a particular type is a model of a concept. Nevertheless, concepts are an extremely important part of the STL. Using concepts makes it possible to write programs that cleanly separate interface from implementation: the author of <code>find</code> only has to consider the interface specified by the concept <b>Input Iterator</b>, rather than the implementation of every possible type that conforms to that concept. Similarly, if you want to use <code>find</code>, you need only to ensure that the arguments you pass to it are models of <b>Input Iterator. </b>This is the reason why <code>find</code> and <code>reverse</code> can be used with <code>list</code>s, <code>vector</code>s, C arrays, and many other types: programming in terms of concepts, rather than in terms of specific types, makes it possible to reuse software components and to combine components together.  <h2>Refinement</h2>
<p>
<b>Input Iterator</b> is, in fact, a rather weak concept: that is, it imposes very few requirements. An <b>Input Iterator</b> must support a subset of pointer arithmetic (it must be possible to increment an <b>Input Iterator</b> using prefix and postfix <code>operator++</code>), but need not support all operations of pointer arithmetic. This is sufficient for <code><a class="el" href="stldoc_find.html">find</a></code>, but some other algorithms require that their arguments satisfy additional requirements. <code><a class="el" href="stldoc_reverse.html">reverse</a></code>, for example, must be able to decrement its arguments as well as increment them; it uses the expression <code>--last</code>. In terms of concepts, we say that <code>reverse</code>'s arguments must be models of <b><a class="el" href="stldoc_BidirectionalIterator.html">BidirectionalIterator</a></b> rather than <b>Input Iterator</b>.  <p>
The <b>Bidirectional Iterator</b> concept is very similar to the <b>Input Iterator</b> concept: it simply imposes some additional requirements. The types that are models of <b>Bidirectional Iterator</b> are a subset of the types that are models of<b> Input Iterator</b>: every type that is a model of <b>Bidirectional Iterator</b> is also a model of <b>Input Iterator</b>. <code>Int*</code>, for example, is both a model of <b>Bidirectional Iterator</b> and a model of <b>Input Iterator</b>, but <code><a class="el" href="stldoc_istream_iterator.html">istream_iterator</a></code>, is only a model of <b>Input Iterator</b>: it does not conform to the more stringent <b>Bidirectional Iterator</b> requirements.  <p>
We describe the relationship between <b>Input Iterator</b> and <b>Bidirectional Iterator</b> by saying that <b>Bidirectional Iterator</b> is a <em>refinement</em> of <b>Input Iterator</b>. Refinement of concepts is very much like inheritance of C++ classes; the main reason we use a different word, instead of just calling it "inheritance", is to emphasize that refinement applies to concepts rather than to actual types. <p>
There are actually three more iterator concepts in addition to the two that we have already discussed: the five iterator concepts are <b><a class="el" href="stldoc_OutputIterator.html">OutputIterator</a></b>, <b><a class="el" href="stldoc_InputIterator.html">InputIterator</a></b>, <b><a class="el" href="stldoc_ForwardIterator.html">ForwardIterator</a></b>, <b><a class="el" href="stldoc_BidirectionalIterator.html">BidirectionalIterator</a></b>, and <b><a class="el" href="stldoc_RandomAccessIterator.html">RandomAccessIterator</a>;</b> <b>Forward Iterator</b> is a refinement of <b>Input Iterator</b>, <b>Bidirectional Iterator</b> is a refinement of <b>Forward Iterator</b>, and <b>Random Access Iterator</b> is a refinement of <b>Bidirectional Iterator</b>. (<b><a class="el" href="stldoc_OutputIterator.html">OutputIterator</a></b> is related to the other four concepts, but it is not part of the hierarchy of refinement: it is not a refinement of any of the other iterator concepts, and none of the other iterator concepts are refinements of it.)<p>
The <em><a class="el" href="stldoc_Iterators.html">Iterators</a></em> has more information about iterators in general.  <p>
Container classes, like iterators, are organized into a hierarchy of concepts. All containers are models of the concept <b><a class="el" href="stldoc_Container.html">Container</a></b>; more refined concepts, such as <b><a class="el" href="stldoc_Sequence.html">Sequence</a></b> and <b><a class="el" href="stldoc_AssociativeContainer.html">AssociativeContainer</a></b>, describe specific types of containers.  <h2>Other parts of the STL</h2>
<p>
If you understand algorithms, iterators, and containers, then you understand almost everything there is to know about the STL. The STL does, however, include several other types of components.  <p>
First, the STL includes several <em>utilities</em>: very basic concepts and functions that are used in many different parts of the library. The concept<b> <a class="el" href="stldoc_Assignable.html">Assignable</a></b>, for example, describes types that have assignment operators and copy constructors; almost all STL classes are models of <b>Assignable</b>, and almost all STL algorithms require their arguments to be models of <b>Assignable</b>.  <p>
Second, the STL includes some low-level mechanisms for allocating and deallocating memory. <em><a class="el" href="stldoc_Allocators.html">Allocators</a></em> are very specialized, and you can safely ignore them for almost all purposes.  <p>
Finally, the STL includes a large collection of <em><a class="el" href="stldoc_functors.html">functors</a></em>, also known as <em>functors</em>. Just as iterators are a generalization of pointers, function objects are a generalization of functions: a function object is anything that you can call using the ordinary function call syntax. There are several different concepts relating to function objects, including <b><a class="el" href="stldoc_UnaryFunction.html">UnaryFunction</a></b> (a function object that takes a single argument, <em>i.e.</em> one that is called as <code>f(x)</code>) and <b><a class="el" href="stldoc_BinaryFunction.html">BinaryFunction</a></b> (a function object that takes two arguments, <em>i.e.</em> one that is called as <code>f(x, y)</code>). Function objects are an important part of generic programming because they allow abstraction not only over the types of objects, but also over the operations that are being performed.  </div>

<!-- Begin Footer -->
</td></tr>
</table>
</div> <!-- content -->
<div class='footerdiv'>
    <div id='footersub'>
        <ul>
            <li><a href="http://www.adobe.com/go/gftray_foot_aboutadobe">Company</a>&nbsp;|&nbsp;</li>
            <li><a href="http://www.adobe.com/go/gftray_foot_privacy_security">Online Privacy Policy</a>&nbsp;|&nbsp;</li>
            <li><a href="http://www.adobe.com/go/gftray_foot_terms">Terms of Use</a>&nbsp;|&nbsp;</li>
    
            <li><a href="http://www.adobe.com/go/gftray_foot_contact_adobe">Contact Us</a>&nbsp;|&nbsp;</li>
            <li><a href="http://www.adobe.com/go/gftray_foot_accessibility">Accessibility</a>&nbsp;|&nbsp;</li>
            <li><a href="http://www.adobe.com/go/gftray_foot_report_piracy">Report Piracy</a>&nbsp;|&nbsp;</li>
            <li><a href="http://www.adobe.com/go/gftray_foot_permissions_trademarks">Permissions &amp; Trademarks</a>&nbsp;|&nbsp;</li>
            <li><a href="http://www.adobe.com/go/gftray_foot_product_license_agreements">Product License Agreements</a>&nbsp;|&nbsp;</li>
    
            <li><a href="http://www.adobe.com/go/gftray_foot_feedback">Send Feedback</a></li>
        </ul>
        <div>
            <p>Copyright &#169; 2006-2007 Adobe Systems Incorporated.</p>
            <p>Use of this website signifies your agreement to the <a href="http://www.adobe.com/go/gftray_foot_terms">Terms of Use</a> and <a href="http://www.adobe.com/go/gftray_foot_privacy_security">Online Privacy Policy</a>.</p>
            <p>Search powered by <a href="http://www.google.com/" target="new">Google</a></p>
        </div>
	</div>
</div>
<script type="text/javascript">
_uacct = "UA-396569-1";
urchinTracker();
</script>
</body>
</html>
