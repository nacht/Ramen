<!--
    Copyright 2005-2008 Adobe Systems Incorporated
    Distributed under the MIT License (see accompanying file LICENSE_1_0_0.txt
    or a copy at http://stlab.adobe.com/licenses.html)

    Some files are held under additional license.
    Please see "http://stlab.adobe.com/licenses.html" for more information.
-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
    <TITLE>Adobe Software Technology Lab: move.hpp Source File</TITLE>
    <META HTTP-EQUIV="content-type" CONTENT="text/html;charset=ISO-8859-1"/>
    <LINK TYPE="text/css" REL="stylesheet" HREF="adobe_source.css"/>
    <LINK REL="alternate" TITLE="stlab.adobe.com RSS" HREF="http://sourceforge.net/export/rss2_projnews.php?group_id=132417&amp;rss_fulltext=1" TYPE="application/rss+xml"/>
    <script src="http://www.google-analytics.com/urchin.js" type="text/javascript"></script>
</head>
<body>
<div id='content'>
<table><tr>
<td colspan='5'>
    <div id='opensource_banner'>
    <table style='width: 100%; padding: 5px;'><tr>
    <td align='left'>
        <a href='index.html' style='border: none'><img src='stlab2007.jpg' alt="stlab.adobe.com"/></a>
    </td>
    <td align='right'>
        <a href='http://www.adobe.com' style='border: none'><img src='adobe_hlogo.gif' alt="Adobe Systems Incorporated"/></a>
    </td>
    </tr></table>
    </div>
</td></tr><tr>
<td valign="top">
    <div id='navtable' height='100%'>
    <div style='margin: 5px'>
        <h4>Documentation</h4>

        <a href="group__asl__overview.html">Overview</a><br/>
        <a href="asl_readme.html">Building ASL</a><br/>
        <a href="asl_toc.html">Documentation</a><br/>
        <a href="http://stlab.adobe.com/wiki/index.php/Supplementary_ASL_Documentation">Library Wiki Docs</a><br/>
        <a href="asl_indices.html">Indices</a><br/>
        <a href="http://stlab.adobe.com/perforce/">Browse Perforce</a><br/>

        <h4>More Info</h4>

        <a href="asl_release_notes.html">Release Notes</a><br/>
        <a href="http://stlab.adobe.com/wiki/">Wiki</a><br/>
        <a href="asl_search.html">Site Search</a><br/>
        <a href="licenses.html">License</a><br/>
        <a href="success_stories.html">Success Stories</a><br/>
        <a href="asl_contributors.html">Contributors</a><br/>

        <h4>Media</h4>

        <a href="http://sourceforge.net/project/showfiles.php?group_id=132417&amp;package_id=145420">Download</a><br/>
        <a href="asl_download_perforce.html">Perforce Depots</a><br/>

        <h4>Support</h4>

        <a href="http://sourceforge.net/projects/adobe-source/">ASL SourceForge Home</a><br/>
        <a href="http://sourceforge.net/mail/?group_id=132417">Mailing Lists</a><br/>
        <a href="http://sourceforge.net/forum/?group_id=132417">Discussion Forums</a><br/>
        <a href="http://sourceforge.net/tracker/?atid=724218&amp;group_id=132417&amp;func=browse">Report Bugs</a><br/>
        <a href="http://sourceforge.net/tracker/?atid=724221&amp;group_id=132417&amp;func=browse">Suggest Features</a><br/>
        <a href="asl_contributing.html">Contribute to ASL</a><br/>

        <h4>RSS</h4>

        <a href="http://sourceforge.net/export/rss2_projnews.php?group_id=132417">Short-text news</a><br/>
        <a href="http://sourceforge.net/export/rss2_projnews.php?group_id=132417&amp;rss_fulltext=1">Full-text news</a><br/>
        <a href="http://sourceforge.net/export/rss2_projfiles.php?group_id=132417">File releases</a><br/>

        <h4>Other Adobe Projects</h4>

        <a href="adobe_apollo.html">Adobe Air</a><br/>
        <a href="http://stlab.adobe.com/gil/">Adobe GIL</a><br/>
        <a href="http://stlab.adobe.com/performance/">C++ Benchmarks</a><br/>
        <a href="http://labs.adobe.com">Adobe Labs</a><br/>
        <a href="http://stlab.adobe.com/amg/">Adobe Media Gallery</a><br/>
        <a href="http://www.adobe.com/products/xmp/">Adobe XMP</a><br/>
        <a href="http://www.mozilla.org/projects/tamarin">Tamarin project<br/>(Mozilla Foundation)</a><br/>

        <h4>Other Resources</h4>

        <a href="http://boost.org">Boost</a><br/>
        <a href="http://www.riaforge.com/">RIAForge</a><br/>
        <a href="http://www.sgi.com/tech/stl">SGI STL</a><br/>
    </div>
    </div>
</td>
<td id='maintable' width="100%" valign="top">

<!-- End Header -->
<!-- Generated by Doxygen 1.5.9 -->
<h1>move.hpp</h1><a href="move_8hpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment">    Copyright 2005-2007 Adobe Systems Incorporated</span>
<a name="l00003"></a>00003 <span class="comment">    Distributed under the MIT License (see accompanying file LICENSE_1_0_0.txt</span>
<a name="l00004"></a>00004 <span class="comment">    or a copy at http://stlab.adobe.com/licenses.html)</span>
<a name="l00005"></a>00005 <span class="comment">*/</span>
<a name="l00006"></a>00006 
<a name="l00007"></a>00007 <span class="comment">/*************************************************************************************************/</span>
<a name="l00008"></a>00008 
<a name="l00009"></a>00009 <span class="preprocessor">#ifndef ADOBE_MOVE_HPP</span>
<a name="l00010"></a>00010 <span class="preprocessor"></span><span class="preprocessor">#define ADOBE_MOVE_HPP</span>
<a name="l00011"></a>00011 <span class="preprocessor"></span>
<a name="l00012"></a>00012 <span class="preprocessor">#include &lt;cassert&gt;</span>
<a name="l00013"></a>00013 <span class="preprocessor">#include &lt;iterator&gt;</span>
<a name="l00014"></a>00014 <span class="preprocessor">#include &lt;memory&gt;</span>
<a name="l00015"></a>00015 
<a name="l00016"></a>00016 <span class="preprocessor">#include &lt;boost/iterator/iterator_adaptor.hpp&gt;</span>
<a name="l00017"></a>00017 <span class="preprocessor">#include &lt;boost/mpl/bool.hpp&gt;</span>
<a name="l00018"></a>00018 <span class="preprocessor">#include &lt;boost/mpl/and.hpp&gt;</span>
<a name="l00019"></a>00019 <span class="preprocessor">#include &lt;boost/mpl/or.hpp&gt;</span>
<a name="l00020"></a>00020 <span class="preprocessor">#include &lt;boost/mpl/not.hpp&gt;</span>
<a name="l00021"></a>00021 <span class="preprocessor">#include &lt;boost/mpl/assert.hpp&gt;</span>
<a name="l00022"></a>00022 <span class="preprocessor">#include &lt;boost/range/begin.hpp&gt;</span>
<a name="l00023"></a>00023 <span class="preprocessor">#include &lt;boost/range/end.hpp&gt;</span>
<a name="l00024"></a>00024 <span class="preprocessor">#include &lt;boost/type_traits/is_convertible.hpp&gt;</span>
<a name="l00025"></a>00025 <span class="preprocessor">#include &lt;boost/type_traits/is_same.hpp&gt;</span>
<a name="l00026"></a>00026 <span class="preprocessor">#include &lt;boost/type_traits/is_class.hpp&gt;</span>
<a name="l00027"></a>00027 <span class="preprocessor">#include &lt;boost/utility/enable_if.hpp&gt;</span>
<a name="l00028"></a>00028 
<a name="l00247"></a>00247 <span class="comment">/*************************************************************************************************/</span>
<a name="l00248"></a>00248 
<a name="l00249"></a>00249 <span class="keyword">namespace </span>adobe {
<a name="l00250"></a>00250 
<a name="l00251"></a>00251 <span class="comment">/*************************************************************************************************/</span>
<a name="l00252"></a>00252 
<a name="l00253"></a>00253 <span class="keyword">namespace </span>implementation {
<a name="l00254"></a>00254 
<a name="l00255"></a>00255 <span class="comment">/*************************************************************************************************/</span>
<a name="l00256"></a>00256 
<a name="l00257"></a>00257 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;  
<a name="l00258"></a>00258 <span class="keyword">struct </span>class_has_move_assign {  
<a name="l00259"></a>00259     <span class="keyword">class </span>type {
<a name="l00260"></a>00260         <span class="keyword">typedef</span> T&amp; (T::*E)(T t);  
<a name="l00261"></a>00261         <span class="keyword">typedef</span> char (&amp;no_type)[1];  
<a name="l00262"></a>00262         <span class="keyword">typedef</span> char (&amp;yes_type)[2];  
<a name="l00263"></a>00263         <span class="keyword">template</span> &lt;E e&gt; <span class="keyword">struct </span>sfinae { <span class="keyword">typedef</span> yes_type type; };  
<a name="l00264"></a>00264         <span class="keyword">template</span> &lt;<span class="keyword">class</span> U&gt;  
<a name="l00265"></a>00265         <span class="keyword">static</span> <span class="keyword">typename</span> sfinae&lt;&amp;U::operator=&gt;::type <a class="code" href="namespaceadobe_1_1dictionary__arg__stream__detail.html#5a658876e3900e0dd757cc5f95b1ff0f">test</a>(<span class="keywordtype">int</span>);  
<a name="l00266"></a>00266         <span class="keyword">template</span> &lt;<span class="keyword">class</span> U&gt;  
<a name="l00267"></a>00267         <span class="keyword">static</span> no_type <a class="code" href="namespaceadobe_1_1dictionary__arg__stream__detail.html#5a658876e3900e0dd757cc5f95b1ff0f">test</a>(...);  
<a name="l00268"></a>00268     <span class="keyword">public</span>:  
<a name="l00269"></a>00269         <span class="keyword">enum</span> {value = <span class="keyword">sizeof</span>(test&lt;T&gt;(1)) == <span class="keyword">sizeof</span>(yes_type)};  
<a name="l00270"></a>00270     };
<a name="l00271"></a>00271  };  
<a name="l00272"></a>00272 
<a name="l00273"></a>00273 <span class="comment">/*************************************************************************************************/</span>
<a name="l00274"></a>00274 
<a name="l00275"></a>00275 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
<a name="l00276"></a>00276 <span class="keyword">struct </span>has_move_assign : boost::mpl::and_&lt;boost::is_class&lt;T&gt;, class_has_move_assign&lt;T&gt; &gt; {};
<a name="l00277"></a>00277 
<a name="l00278"></a>00278 <span class="comment">/*************************************************************************************************/</span>
<a name="l00279"></a>00279 
<a name="l00280"></a>00280 <span class="keyword">class </span>test_can_convert_anything { };
<a name="l00281"></a>00281 
<a name="l00282"></a>00282 <span class="comment">/*************************************************************************************************/</span>
<a name="l00283"></a>00283 
<a name="l00284"></a>00284 } <span class="comment">//namespace implementation</span>
<a name="l00285"></a>00285 
<a name="l00286"></a>00286 
<a name="l00287"></a>00287 <span class="comment">/*************************************************************************************************/</span>
<a name="l00288"></a>00288 
<a name="l00289"></a>00289 <span class="comment">/*</span>
<a name="l00290"></a>00290 <span class="comment">    REVISIT (sparent@adobe.com): This is a work around for Boost 1.34.1 and VC++ 2008 where</span>
<a name="l00291"></a>00291 <span class="comment">    boost::is_convertible&lt;T, T&gt; fails to compile.</span>
<a name="l00292"></a>00292 <span class="comment">*/</span>
<a name="l00293"></a>00293 
<a name="l00294"></a>00294 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;
<a name="l00295"></a><a class="code" href="structadobe_1_1is__convertible.html">00295</a> <span class="keyword">struct </span><a class="code" href="structadobe_1_1is__convertible.html">is_convertible</a> : boost::mpl::or_&lt;
<a name="l00296"></a>00296     boost::is_same&lt;T, U&gt;,
<a name="l00297"></a>00297     boost::is_convertible&lt;T, U&gt;
<a name="l00298"></a>00298 &gt; { };
<a name="l00299"></a>00299 
<a name="l00305"></a>00305 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l00306"></a><a class="code" href="structadobe_1_1move__from.html">00306</a> <span class="keyword">struct </span><a class="code" href="structadobe_1_1move__from.html" title="move_from is used for move_ctors.">move_from</a>
<a name="l00307"></a>00307 {
<a name="l00308"></a><a class="code" href="structadobe_1_1move__from.html#412b7113cfaf9209a09a5e61f8e13f8f">00308</a>     <span class="keyword">explicit</span> <a class="code" href="structadobe_1_1move__from.html#412b7113cfaf9209a09a5e61f8e13f8f">move_from</a>(T&amp; x) : source(x) { }
<a name="l00309"></a><a class="code" href="structadobe_1_1move__from.html#3fc86dd652c668de2fecaa29375d0d2b">00309</a>     T&amp; source;
<a name="l00310"></a>00310 };
<a name="l00311"></a>00311 
<a name="l00316"></a>00316 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l00317"></a><a class="code" href="structadobe_1_1is__movable.html">00317</a> <span class="keyword">struct </span><a class="code" href="structadobe_1_1is__movable.html" title="The is_movable trait can be used to identify movable types.">is_movable</a> : boost::mpl::and_&lt;
<a name="l00318"></a>00318                         boost::is_convertible&lt;move_from&lt;T&gt;, T&gt;,
<a name="l00319"></a>00319                         implementation::has_move_assign&lt;T&gt;,
<a name="l00320"></a>00320                         boost::mpl::not_&lt;boost::is_convertible&lt;implementation::test_can_convert_anything, T&gt; &gt;
<a name="l00321"></a>00321                     &gt; { };
<a name="l00322"></a>00322 
<a name="l00323"></a>00323 <span class="comment">/*************************************************************************************************/</span>
<a name="l00324"></a>00324 
<a name="l00332"></a>00332 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,
<a name="l00333"></a>00333           <span class="keyword">typename</span> U = T,
<a name="l00334"></a>00334           <span class="keyword">typename</span> R = <span class="keywordtype">void</span>*&gt;
<a name="l00335"></a><a class="code" href="structadobe_1_1copy__sink.html">00335</a> <span class="keyword">struct </span><a class="code" href="structadobe_1_1copy__sink.html" title="copy_sink and move_sink are used to select between overloaded operations according...">copy_sink</a> : boost::enable_if&lt;
<a name="l00336"></a>00336                         boost::mpl::and_&lt;
<a name="l00337"></a>00337                             adobe::is_convertible&lt;T, U&gt;,                           
<a name="l00338"></a>00338                             boost::mpl::not_&lt;is_movable&lt;T&gt; &gt;
<a name="l00339"></a>00339                         &gt;,
<a name="l00340"></a>00340                         R
<a name="l00341"></a>00341                     &gt;
<a name="l00342"></a>00342 { };
<a name="l00343"></a>00343 
<a name="l00344"></a>00344 <span class="comment">/*************************************************************************************************/</span>
<a name="l00345"></a>00345 
<a name="l00353"></a>00353 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,
<a name="l00354"></a>00354           <span class="keyword">typename</span> U = T,
<a name="l00355"></a>00355           <span class="keyword">typename</span> R = <span class="keywordtype">void</span>*&gt;
<a name="l00356"></a><a class="code" href="structadobe_1_1move__sink.html">00356</a> <span class="keyword">struct </span><a class="code" href="structadobe_1_1move__sink.html" title="move_sink and copy_sink are used to select between overloaded operations according...">move_sink</a> : boost::enable_if&lt;
<a name="l00357"></a>00357                         boost::mpl::and_&lt;
<a name="l00358"></a>00358                             adobe::is_convertible&lt;T, U&gt;,                            
<a name="l00359"></a>00359                             is_movable&lt;T&gt;
<a name="l00360"></a>00360                         &gt;,
<a name="l00361"></a>00361                         R
<a name="l00362"></a>00362                     &gt;
<a name="l00363"></a>00363 { };
<a name="l00364"></a>00364 
<a name="l00365"></a>00365 <span class="comment">/*************************************************************************************************/</span>
<a name="l00366"></a>00366 
<a name="l00374"></a>00374 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l00375"></a><a class="code" href="group__move__related.html#g19621039777830b4c316f8956bc5d42f">00375</a> T <a class="code" href="group__move__related.html#g19621039777830b4c316f8956bc5d42f" title="This version of move is selected when T is_movable . It in turn calls the move constructor...">move</a>(T&amp; x, <span class="keyword">typename</span> <a class="code" href="structadobe_1_1move__sink.html" title="move_sink and copy_sink are used to select between overloaded operations according...">move_sink&lt;T&gt;::type</a> = 0) { <span class="keywordflow">return</span> T(<a class="code" href="structadobe_1_1move__from.html" title="move_from is used for move_ctors.">move_from&lt;T&gt;</a>(x)); }
<a name="l00376"></a>00376 
<a name="l00377"></a>00377 <span class="comment">/*************************************************************************************************/</span>
<a name="l00378"></a>00378 
<a name="l00384"></a>00384 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l00385"></a><a class="code" href="group__move__related.html#gb618fdd195c9dee5111ca0b926aa1f2c">00385</a> T&amp; <a class="code" href="group__move__related.html#g19621039777830b4c316f8956bc5d42f" title="This version of move is selected when T is_movable . It in turn calls the move constructor...">move</a>(T&amp; x, <span class="keyword">typename</span> <a class="code" href="structadobe_1_1copy__sink.html" title="copy_sink and move_sink are used to select between overloaded operations according...">copy_sink&lt;T&gt;::type</a> = 0) { <span class="keywordflow">return</span> x; }
<a name="l00386"></a>00386 
<a name="l00387"></a>00387 <span class="comment">/*************************************************************************************************/</span>
<a name="l00388"></a>00388 
<a name="l00394"></a>00394 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> I, <span class="comment">// I models InputIterator</span>
<a name="l00395"></a>00395           <span class="keyword">typename</span> O&gt; <span class="comment">// O models OutputIterator</span>
<a name="l00396"></a><a class="code" href="group__move__related.html#g772e7d266930a324c8d53ceaf6814db3">00396</a> O <a class="code" href="group__move__related.html#g19621039777830b4c316f8956bc5d42f" title="This version of move is selected when T is_movable . It in turn calls the move constructor...">move</a>(I f, I l, O result)
<a name="l00397"></a>00397 {
<a name="l00398"></a>00398     <span class="keywordflow">while</span> (f != l) {
<a name="l00399"></a>00399         *result = <a class="code" href="group__move__related.html#g19621039777830b4c316f8956bc5d42f" title="This version of move is selected when T is_movable . It in turn calls the move constructor...">move</a>(*f);
<a name="l00400"></a>00400         ++f; ++result;
<a name="l00401"></a>00401     }
<a name="l00402"></a>00402     <span class="keywordflow">return</span> result;
<a name="l00403"></a>00403 }
<a name="l00404"></a>00404 
<a name="l00405"></a>00405 <span class="comment">/*************************************************************************************************/</span>
<a name="l00406"></a>00406 
<a name="l00412"></a>00412 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> I, <span class="comment">// I models InputRange</span>
<a name="l00413"></a>00413           <span class="keyword">typename</span> O&gt; <span class="comment">// O models OutputIterator</span>
<a name="l00414"></a><a class="code" href="group__move__related.html#g861b306d997a7c9750d75385f6b9fd4b">00414</a> <span class="keyword">inline</span> O <a class="code" href="group__move__related.html#g19621039777830b4c316f8956bc5d42f" title="This version of move is selected when T is_movable . It in turn calls the move constructor...">move</a>(I&amp; in, O out) { <span class="keywordflow">return</span> <a class="code" href="group__move__related.html#g19621039777830b4c316f8956bc5d42f" title="This version of move is selected when T is_movable . It in turn calls the move constructor...">move</a>(boost::begin(in), boost::end(in), out); }
<a name="l00415"></a>00415 
<a name="l00416"></a>00416 <span class="comment">/*************************************************************************************************/</span>
<a name="l00417"></a>00417  
<a name="l00423"></a>00423 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> I, <span class="comment">// I models BidirectionalIterator</span>
<a name="l00424"></a>00424           <span class="keyword">typename</span> O&gt; <span class="comment">// O models BidirectionalIterator</span>
<a name="l00425"></a><a class="code" href="group__move__related.html#g5447683d5fde8fba2362a1ab114eda89">00425</a> O <a class="code" href="group__move__related.html#g5447683d5fde8fba2362a1ab114eda89" title="Iterator pair version of move_backwards. Similar to std::copy_backwards but with...">move_backward</a>(I f, I l, O result)
<a name="l00426"></a>00426 {
<a name="l00427"></a>00427     <span class="keywordflow">while</span> (f != l) {
<a name="l00428"></a>00428         --l; --result;
<a name="l00429"></a>00429         *result = <a class="code" href="group__move__related.html#g19621039777830b4c316f8956bc5d42f" title="This version of move is selected when T is_movable . It in turn calls the move constructor...">move</a>(*l);
<a name="l00430"></a>00430     }
<a name="l00431"></a>00431     <span class="keywordflow">return</span> result;
<a name="l00432"></a>00432 }
<a name="l00433"></a>00433 
<a name="l00434"></a>00434 <span class="comment">/*************************************************************************************************/</span>
<a name="l00435"></a>00435 
<a name="l00441"></a>00441 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> I, <span class="comment">// I models BidirectionalRange</span>
<a name="l00442"></a>00442           <span class="keyword">typename</span> O&gt; <span class="comment">// O models BidirectionalIterator</span>
<a name="l00443"></a><a class="code" href="group__move__related.html#g9f89399cacd95d825ff569aa3ce94e1c">00443</a> <span class="keyword">inline</span> O <a class="code" href="group__move__related.html#g5447683d5fde8fba2362a1ab114eda89" title="Iterator pair version of move_backwards. Similar to std::copy_backwards but with...">move_backward</a>(I&amp; in, O out)
<a name="l00444"></a>00444 { <span class="keywordflow">return</span> <a class="code" href="group__move__related.html#g5447683d5fde8fba2362a1ab114eda89" title="Iterator pair version of move_backwards. Similar to std::copy_backwards but with...">move_backward</a>(boost::begin(in), boost::end(in), out); }
<a name="l00445"></a>00445 
<a name="l00446"></a>00446 <span class="comment">/*************************************************************************************************/</span>
<a name="l00447"></a>00447 
<a name="l00454"></a>00454 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> C&gt; <span class="comment">// C models Container</span>
<a name="l00455"></a><a class="code" href="classadobe_1_1back__move__iterator.html">00455</a> <span class="keyword">class </span><a class="code" href="classadobe_1_1back__move__iterator.html" title="Similar to std::back_insert_iterator but with move semantics, for movable types,...">back_move_iterator</a> : <span class="keyword">public</span> std::iterator&lt;std::output_iterator_tag, void, void, void, void&gt;
<a name="l00456"></a>00456 {
<a name="l00457"></a>00457     C* container_m;
<a name="l00458"></a>00458     
<a name="l00459"></a>00459  <span class="keyword">public</span>:
<a name="l00460"></a><a class="code" href="classadobe_1_1back__move__iterator.html#75bf1310753fc892ae229e53ac1173a3">00460</a>     <span class="keyword">typedef</span> C container_type;
<a name="l00461"></a>00461     
<a name="l00462"></a><a class="code" href="classadobe_1_1back__move__iterator.html#677c8b4200cb53dad342fe54047bdde2">00462</a>     <span class="keyword">explicit</span> <a class="code" href="classadobe_1_1back__move__iterator.html#677c8b4200cb53dad342fe54047bdde2">back_move_iterator</a>(C&amp; x) : container_m(&amp;x) { }
<a name="l00463"></a>00463     
<a name="l00464"></a><a class="code" href="classadobe_1_1back__move__iterator.html#4061ca60f83ef77bb65d4651a44fb52c">00464</a>     <a class="code" href="classadobe_1_1back__move__iterator.html" title="Similar to std::back_insert_iterator but with move semantics, for movable types,...">back_move_iterator</a>&amp; operator=(<span class="keyword">typename</span> C::value_type x)
<a name="l00465"></a>00465     { container_m-&gt;push_back(<a class="code" href="group__move__related.html#g19621039777830b4c316f8956bc5d42f" title="This version of move is selected when T is_movable . It in turn calls the move constructor...">move</a>(x)); <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l00466"></a>00466     
<a name="l00467"></a><a class="code" href="classadobe_1_1back__move__iterator.html#abcd1b19fd59cbee3088e1110c883b36">00467</a>     <a class="code" href="classadobe_1_1back__move__iterator.html" title="Similar to std::back_insert_iterator but with move semantics, for movable types,...">back_move_iterator</a>&amp; <a class="code" href="classadobe_1_1back__move__iterator.html#abcd1b19fd59cbee3088e1110c883b36">operator*</a>() { <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l00468"></a><a class="code" href="classadobe_1_1back__move__iterator.html#022874be593b232e331e1fa3f44e4860">00468</a>     <a class="code" href="classadobe_1_1back__move__iterator.html" title="Similar to std::back_insert_iterator but with move semantics, for movable types,...">back_move_iterator</a>&amp; <a class="code" href="classadobe_1_1back__move__iterator.html#022874be593b232e331e1fa3f44e4860">operator++</a>() { <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l00469"></a><a class="code" href="classadobe_1_1back__move__iterator.html#70bdddf89cbebf388754f09d704bd10b">00469</a>     <a class="code" href="classadobe_1_1back__move__iterator.html" title="Similar to std::back_insert_iterator but with move semantics, for movable types,...">back_move_iterator</a>&amp; <a class="code" href="classadobe_1_1back__move__iterator.html#70bdddf89cbebf388754f09d704bd10b">operator++</a>(<span class="keywordtype">int</span>) { <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l00470"></a>00470 };
<a name="l00471"></a>00471 
<a name="l00472"></a>00472 <span class="comment">/*************************************************************************************************/</span>
<a name="l00473"></a>00473 
<a name="l00480"></a>00480 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> C&gt; <span class="comment">// C models Container</span>
<a name="l00481"></a><a class="code" href="group__move__related.html#g2bce3bf213a2762f43d4d5ecdf86e990">00481</a> <span class="keyword">inline</span> <a class="code" href="classadobe_1_1back__move__iterator.html" title="Similar to std::back_insert_iterator but with move semantics, for movable types,...">back_move_iterator&lt;C&gt;</a> <a class="code" href="group__move__related.html#g2bce3bf213a2762f43d4d5ecdf86e990" title="Similar to std::back_inserter but with move semantics, for movable types, otherwise...">back_mover</a>(C&amp; x) { <span class="keywordflow">return</span> <a class="code" href="classadobe_1_1back__move__iterator.html" title="Similar to std::back_insert_iterator but with move semantics, for movable types,...">back_move_iterator&lt;C&gt;</a>(x); }
<a name="l00482"></a>00482 
<a name="l00483"></a>00483 <span class="comment">/*************************************************************************************************/</span>
<a name="l00484"></a>00484 
<a name="l00490"></a>00490 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt; <span class="comment">// T models Regular</span>
<a name="l00491"></a><a class="code" href="group__move__related.html#g526400c08893d7d421ef40dff01dfa7c">00491</a> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="group__move__related.html#g526400c08893d7d421ef40dff01dfa7c" title="Placement move construction, selected when T is_movable is true.">move_construct</a>(T* p, U&amp; x, <span class="keyword">typename</span> <a class="code" href="structadobe_1_1move__sink.html" title="move_sink and copy_sink are used to select between overloaded operations according...">move_sink&lt;U, T&gt;::type</a> = 0)
<a name="l00492"></a>00492 {
<a name="l00493"></a>00493     ::new(<span class="keyword">static_cast&lt;</span><span class="keywordtype">void</span>*<span class="keyword">&gt;</span>(p)) T(<a class="code" href="group__move__related.html#g19621039777830b4c316f8956bc5d42f" title="This version of move is selected when T is_movable . It in turn calls the move constructor...">move</a>(x));
<a name="l00494"></a>00494 }
<a name="l00495"></a>00495 
<a name="l00496"></a>00496 <span class="comment">/*************************************************************************************************/</span>
<a name="l00497"></a>00497 
<a name="l00498"></a>00498 
<a name="l00503"></a>00503 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt; <span class="comment">// T models Regular</span>
<a name="l00504"></a><a class="code" href="group__move__related.html#gba0d88eb4e6a90cc300de32d97bcf729">00504</a> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="group__move__related.html#g526400c08893d7d421ef40dff01dfa7c" title="Placement move construction, selected when T is_movable is true.">move_construct</a>(T* p, <span class="keyword">const</span> U&amp; x, <span class="keyword">typename</span> <a class="code" href="structadobe_1_1copy__sink.html" title="copy_sink and move_sink are used to select between overloaded operations according...">copy_sink&lt;U, T&gt;::type</a> = 0)
<a name="l00505"></a>00505 {
<a name="l00506"></a>00506     ::new(<span class="keyword">static_cast&lt;</span><span class="keywordtype">void</span>*<span class="keyword">&gt;</span>(p)) T(x);
<a name="l00507"></a>00507 }
<a name="l00508"></a>00508 
<a name="l00509"></a>00509 <span class="comment">/*************************************************************************************************/</span>
<a name="l00510"></a>00510 
<a name="l00516"></a>00516 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> I, <span class="comment">// I models InputIterator</span>
<a name="l00517"></a>00517           <span class="keyword">typename</span> F&gt; <span class="comment">// F models ForwardIterator</span>
<a name="l00518"></a><a class="code" href="group__move__related.html#ge8d7bf1a2a8a34622181803f3cb77f7e">00518</a> F <a class="code" href="group__move__related.html#ge8d7bf1a2a8a34622181803f3cb77f7e" title="Similar to std::uninitialized_copy but with move semantics, for movable types.">uninitialized_move</a>(I f, I l, F r,
<a name="l00519"></a>00519         <span class="keyword">typename</span> <a class="code" href="structadobe_1_1move__sink.html" title="move_sink and copy_sink are used to select between overloaded operations according...">move_sink</a>&lt;<span class="keyword">typename</span> std::iterator_traits&lt;I&gt;::value_type&gt;::type = 0)
<a name="l00520"></a>00520 {
<a name="l00521"></a>00521     <span class="keywordflow">while</span> (f != l) {
<a name="l00522"></a>00522         <a class="code" href="group__move__related.html#g526400c08893d7d421ef40dff01dfa7c" title="Placement move construction, selected when T is_movable is true.">move_construct</a>(&amp;*r, *f);
<a name="l00523"></a>00523         ++f; ++r;
<a name="l00524"></a>00524     }
<a name="l00525"></a>00525     <span class="keywordflow">return</span> r;
<a name="l00526"></a>00526 }
<a name="l00527"></a>00527 
<a name="l00528"></a>00528 <span class="comment">/*************************************************************************************************/</span>
<a name="l00529"></a>00529 
<a name="l00534"></a>00534 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> I, <span class="comment">// I models InputIterator</span>
<a name="l00535"></a>00535           <span class="keyword">typename</span> F&gt; <span class="comment">// F models ForwardIterator</span>
<a name="l00536"></a><a class="code" href="group__move__related.html#gd89b3999fc477d980388f0c572673d44">00536</a> F <a class="code" href="group__move__related.html#ge8d7bf1a2a8a34622181803f3cb77f7e" title="Similar to std::uninitialized_copy but with move semantics, for movable types.">uninitialized_move</a>(I f, I l, F r,
<a name="l00537"></a>00537         <span class="keyword">typename</span> <a class="code" href="structadobe_1_1copy__sink.html" title="copy_sink and move_sink are used to select between overloaded operations according...">copy_sink</a>&lt;<span class="keyword">typename</span> std::iterator_traits&lt;I&gt;::value_type&gt;::type = 0)
<a name="l00538"></a>00538 {
<a name="l00539"></a>00539     <span class="keywordflow">return</span> std::uninitialized_copy(f, l, r);
<a name="l00540"></a>00540 }
<a name="l00541"></a>00541 
<a name="l00542"></a>00542 <span class="comment">/*************************************************************************************************/</span>
<a name="l00543"></a>00543 
<a name="l00544"></a>00544 } <span class="comment">// namespace adobe</span>
<a name="l00545"></a>00545 
<a name="l00546"></a>00546 <span class="comment">/*************************************************************************************************/</span>
<a name="l00547"></a>00547 
<a name="l00548"></a>00548 <span class="preprocessor">#endif</span>
<a name="l00549"></a>00549 <span class="preprocessor"></span>
<a name="l00550"></a>00550 <span class="comment">/*************************************************************************************************/</span>
</pre></div></div>

<!-- Begin Footer -->
</td></tr>
</table>
</div> <!-- content -->
<div class='footerdiv'>
    <div id='footersub'>
        <ul>
            <li><a href="http://www.adobe.com/go/gftray_foot_aboutadobe">Company</a>&nbsp;|&nbsp;</li>
            <li><a href="http://www.adobe.com/go/gftray_foot_privacy_security">Online Privacy Policy</a>&nbsp;|&nbsp;</li>
            <li><a href="http://www.adobe.com/go/gftray_foot_terms">Terms of Use</a>&nbsp;|&nbsp;</li>
    
            <li><a href="http://www.adobe.com/go/gftray_foot_contact_adobe">Contact Us</a>&nbsp;|&nbsp;</li>
            <li><a href="http://www.adobe.com/go/gftray_foot_accessibility">Accessibility</a>&nbsp;|&nbsp;</li>
            <li><a href="http://www.adobe.com/go/gftray_foot_report_piracy">Report Piracy</a>&nbsp;|&nbsp;</li>
            <li><a href="http://www.adobe.com/go/gftray_foot_permissions_trademarks">Permissions &amp; Trademarks</a>&nbsp;|&nbsp;</li>
            <li><a href="http://www.adobe.com/go/gftray_foot_product_license_agreements">Product License Agreements</a>&nbsp;|&nbsp;</li>
    
            <li><a href="http://www.adobe.com/go/gftray_foot_feedback">Send Feedback</a></li>
        </ul>
        <div>
            <p>Copyright &#169; 2006-2007 Adobe Systems Incorporated.</p>
            <p>Use of this website signifies your agreement to the <a href="http://www.adobe.com/go/gftray_foot_terms">Terms of Use</a> and <a href="http://www.adobe.com/go/gftray_foot_privacy_security">Online Privacy Policy</a>.</p>
            <p>Search powered by <a href="http://www.google.com/" target="new">Google</a></p>
        </div>
	</div>
</div>
<script type="text/javascript">
_uacct = "UA-396569-1";
urchinTracker();
</script>
</body>
</html>
